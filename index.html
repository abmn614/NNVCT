
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¥ç»ç½‘ç»œå¯è§†åŒ–æ„å»ºå·¥å…·ï¼ˆæœ€ç»ˆä¼˜åŒ–ç‰ˆï¼‰</title>
    <!-- å¼•å…¥Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* è¦†ç›– Tailwind æ ·å¼ */
        .space-y-3 > :not([hidden]) ~ :not([hidden]) {
            margin-top: 0 !important;
        }
        .p-3 {
            padding: 0 !important;
        }
        .border {
            border: none !important;
        }
        /* è¡¥å……å°‘é‡è‡ªå®šä¹‰æ ·å¼ */
        canvas {
            border: 1px solid #e2e8f0;
            background-color: #f8fafc;
            cursor: grab;
        }
        .layer-item {
            transition: all 0.3s ease;
        }
        .layer-item:hover {
            background-color: #f1f5f9;
        }
        /* æƒé‡å®¹å™¨æ ·å¼ï¼ˆåŒ…å«å‚æ•°åã€ä¸Šä¸‹æ ‡å’Œè¾“å…¥æ¡†ï¼‰ */
        .weight-container {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transform-origin: center center;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            border-radius: 2px;
            padding: 2px 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            height: 22px;
            font-size: 11px;
            white-space: nowrap;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.15s ease;
        }
        .weight-container:hover,
        .weight-container.visible {
            opacity: 1;
        }
        .weight-label {
            display: inline-flex;
            align-items: center;
            margin-right: 2px;
            font-style: italic;
        }
        .weight-label-w {
            font-size: 12px;
        }
        .weight-scripts {
            display: inline-flex;
            flex-direction: column;
            align-items: flex-start;
            margin-left: 1px;
            line-height: 0.9;
        }
        .weight-superscript {
            font-size: 7px;
            margin-bottom: 1px;
        }
        .weight-subscript {
            font-size: 7px;
            margin-top: 1px;
        }
        .weight-input {
            width: 28px;
            height: 18px;
            font-size: 11px;
            text-align: center;
            border: none;
            border-radius: 2px;
            background: transparent;
            outline: none;
            padding: 0 2px;
            cursor: text;
            pointer-events: auto;
            position: relative;
            z-index: 100;
        }
        .weight-input:focus {
            background: #fff;
            box-shadow: 0 0 2px rgba(59, 130, 246, 0.5);
        }
        /* èŠ‚ç‚¹è‡ªå®šä¹‰å‚æ•°æ ·å¼ï¼ˆæ”¯æŒå¤æ‚å˜é‡åã€ä¸Šä¸‹æ ‡ã€é¡¶æ ‡ã€ç´§å‡‘å¸ƒå±€ï¼‰ */
        .node-param-container {
            position: absolute;
            display: flex;
            align-items: baseline;
            font-size: 11px;
            z-index: 10;
            background-color: #fdfdfd;
            border: 1px solid #ccc;
            border-radius: 2px;
            padding: 2px 3px;
            margin: 0;
            white-space: nowrap;
            min-height: 18px;
            box-sizing: border-box;
            gap: 0;
        }
        /* å‚æ•°ç»„å®¹å™¨é»˜è®¤éšè—ï¼Œæ‚¬æµ®æˆ–å›ºå®šæ—¶æ˜¾ç¤º */
        .node-param-group {
            display: none;
            transition: opacity 0.2s ease;
            z-index: 100; /* æé«˜z-indexï¼Œç¡®ä¿åœ¨è¿çº¿å’Œæƒé‡ä¹‹ä¸Š */
            pointer-events: auto;
        }
        .node-param-group.visible {
            display: block;
        }
        .node-param-group.pinned {
            display: block;
        }
        .node-param-group.hover-active {
            display: block;
        }
        /* å›ºå®šå›¾æ ‡æ ·å¼ */
        .pin-icon {
            cursor: pointer;
            font-size: 12px;
            color: #9ca3af;
            margin-left: 4px;
            transition: color 0.2s ease;
            user-select: none;
        }
        .pin-icon:hover {
            color: #3b82f6;
        }
        .pin-icon.pinned {
            color: #3b82f6;
        }
        /* æŠ˜å å›¾æ ‡æ ·å¼ */
        .collapse-icon {
            cursor: pointer;
            font-size: 12px;
            color: #9ca3af;
            margin-left: 4px;
            transition: color 0.2s, transform 0.2s;
            user-select: none;
        }
        .collapse-icon:hover {
            color: #3b82f6;
        }
        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }
        /* å‚æ•°å†…å®¹åŒºåŸŸ */
        .param-content {
            transition: max-height 0.2s ease, opacity 0.2s ease;
            overflow: hidden;
        }
        .param-content.collapsed {
            max-height: 0 !important;
            opacity: 0;
            padding: 0;
            margin: 0;
        }
        /* èŠ‚ç‚¹å‚æ•°æ ‡ç­¾ï¼ˆæ˜¾ç¤ºåœ¨èŠ‚ç‚¹ä¸Šæ–¹æˆ–ä¸‹æ–¹ï¼‰ */
        .node-param-label {
            position: absolute;
            display: inline-flex;
            align-items: center;
            gap: 2px;
            font-size: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #d1d5db;
            border-radius: 3px;
            padding: 1px 3px;
            z-index: 50;
            white-space: nowrap;
            pointer-events: auto;
        }
        .node-param-label .param-item {
            display: inline-flex;
            align-items: baseline;
        }
        .node-param-label .param-base {
            font-style: italic;
            font-size: 12px;
        }
        .node-param-label .param-value-input {
            width: 28px;
            height: 14px;
            font-size: 10px;
            text-align: center;
            border: none;
            border-radius: 2px;
            background: transparent;
            outline: none;
            padding: 0 2px;
            cursor: text;
            pointer-events: auto;
            color: #dc2626;
        }
        .node-param-label .param-value-input:focus {
            background: #fff;
            box-shadow: 0 0 2px rgba(59, 130, 246, 0.5);
        }
        .node-param-label .param-scripts {
            display: inline-flex;
            flex-direction: column;
            align-items: flex-start;
            margin-left: 0px;
            line-height: 1;
            vertical-align: middle;
        }
        .node-param-label .param-sup {
            font-size: 7px;
            position: relative;
            top: -0.8em;
            left: -0.5em;
            line-height: 1;
        }
        .node-param-label .param-sub {
            font-size: 7px;
            position: relative;
            top: -0.5em;
            left: -0.5em;
            line-height: 1;
        }
        .node-param-label .param-hat {
            position: absolute;
            top: -0.4em;
            left: 0;
            font-size: 7px;
        }
        .node-param-label .param-value {
            font-size: 11px;
        }
        /* å›¾æ ‡å®¹å™¨ */
        .title-icons {
            display: flex;
            align-items: center;
        }
        /* å‚æ•°æ ‡é¢˜å®¹å™¨ - å¯æ‹–åŠ¨ */
        .param-title-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 1px;
            margin-bottom: 2px;
            cursor: move;
            user-select: none;
        }
        .param-title-container:active {
            cursor: grabbing;
        }
        .param-title-text {
            font-size: 9px;
            color: #6b7280;
        }
        /* å˜é‡åå±•ç¤ºå®¹å™¨ï¼ˆæ”¯æŒä¸Šä¸‹æ ‡ã€é¡¶æ ‡ï¼‰- ç´§å¯†è´´åˆå¸ƒå±€ */
        .param-display-container {
            display: inline-flex;
            align-items: baseline;
            position: relative;
            line-height: 1;
            white-space: nowrap;
            gap: 0;
            margin: 0;
            padding: 0;
        }
        .param-base-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
            margin: 0;
            padding: 0;
            gap: 0;
            vertical-align: middle;
            line-height: 1;
            height: 1.5em;
        }
        .param-base {
            font-size: 11px;
            color: #2563eb;
            position: relative;
            z-index: 2;
            display: inline-block;
            font-weight: normal;
            margin: 0;
            padding: 0;
            vertical-align: middle;
            line-height: 1;
        }
        .param-sup {
            font-size: 7px;
            color: #2563eb;
            position: absolute;
            top: -1.5em;
            left: 0;
            margin: 0;
            padding: 0;
            z-index: 3;
            white-space: nowrap;
            font-weight: normal;
            line-height: 1;
            display: inline-block;
        }
        .param-sub {
            font-size: 7px;
            color: #2563eb;
            position: absolute;
            bottom: -1em;
            left: 0;
            margin: 0;
            padding: 0;
            z-index: 3;
            white-space: nowrap;
            font-weight: normal;
            line-height: 1;
            display: inline-block;
        }
        .param-hat {
            font-size: 10px;
            color: #2563eb;
            position: absolute;
            top: 0em;
            text-align: center;
            z-index: 1;
            line-height: 1;
            margin: 0;
            padding: 0;
            vertical-align: middle;
        }
        .param-bar {
            font-size: 10px;
            color: #2563eb;
            position: absolute;
            top: -0.3em;
            left: 0;
            right: 0;
            border-top: 1px solid #2563eb;
            height: 0;
            z-index: 1;
            display: block;
            margin: 0;
            padding: 0;
        }
        .node-param-equal {
            margin: 0 1px;
            color: #64748b;
        }
        .node-param-value {
            width: auto !important;
            min-width: 30px;
            max-width: 80px;
            height: 18px;
            color: #dc2626;
            outline: none;
            border: none;
            background: transparent;
            font-size: 11px;
            padding: 0 2px;
            margin: 0;
            box-sizing: content-box;
        }
        /* å¯è§†åŒ–å®¹å™¨ç›¸å¯¹å®šä½ï¼Œç”¨äºæ‰¿è½½ç»å¯¹å®šä½çš„è¾“å…¥æ¡† */
        .visualization-container {
            position: relative;
            display: inline-block;
            /* ä¸é™åˆ¶å®½åº¦ï¼Œè®©å†…å®¹å¯ä»¥è¶…å‡º wrapper äº§ç”Ÿæ»šåŠ¨ */
        }
        /* å¯è§†åŒ–å¤–å±‚å®¹å™¨ï¼Œæ”¯æŒæ»šåŠ¨ */
        .visualization-wrapper {
            max-width: calc(100vw - 420px); /* é™åˆ¶æœ€å¤§å®½åº¦ï¼Œç•™å‡ºä¾§è¾¹æ ç©ºé—´ */
            min-width: 600px;
            max-height: 80vh;
            overflow: auto;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
        }
        /* èŠ‚ç‚¹å‚æ•°å¼¹æ¡†ï¼ˆæ”¯æŒä¸Šä¸‹æ ‡/é¡¶æ ‡ç‹¬ç«‹è¾“å…¥ï¼‰ */
        .node-param-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px; /* åŠ å®½é€‚é…ä¸Šä¸‹æ ‡è¾“å…¥é¡¹ */
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 20px;
            z-index: 1000;
            display: none;
        }
        .node-param-modal.active {
            display: block;
        }
        .modal-mask {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.3);
            z-index: 999;
            display: none;
        }
        .modal-mask.active {
            display: block;
        }
        .param-item {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-bottom: 0px;
            flex-wrap: wrap;
            padding: 0px;
            border-radius: 4px;
            background: #f9fafb;
            transition: background 0.2s;
        }
        .param-item:hover {
            background: #f3f4f6;
        }
        .param-item.dragging {
            opacity: 0.5;
        }
        .drag-handle {
            cursor: grab;
            color: #9ca3af;
            font-size: 14px;
            line-height: 1;
        }
        .drag-handle:active {
            cursor: grabbing;
        }
        .param-name-group {
            display: flex;
            align-items: center;
            gap: 2px;
        }
        .param-base-input {
            width: 40px;
            height: 18px;
            font-size: 11px;
            border: 1px solid #ddd;
            border-radius: 2px;
            text-align: center;
        }
        .param-sup-input, .param-sub-input {
            width: 30px;
            height: 16px;
            font-size: 9px;
            border: 1px solid #ddd;
            border-radius: 2px;
            text-align: center;
        }
        .param-hat-checkbox {
            width: 16px;
            height: 16px;
            margin: 0 2px;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e2e8f0;
        }
        .close-modal {
            cursor: pointer;
            color: #64748b;
            font-size: 20px;
            line-height: 1;
        }
        .close-modal:hover {
            color: #dc2626;
        }
        /* ç¥ç»å…ƒé—´è·é…ç½®é¡¹æ ·å¼ */
        .node-spacing-config {
            margin: 4px 0 16px 0;
        }
        .spacing-input {
            width: 60px;
            padding: 2px 4px;
            font-size: 12px;
            border: 1px solid #e2e8f0;
            border-radius: 2px;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 md:p-8">
    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">ç¥ç»ç½‘ç»œå¯è§†åŒ–æ„å»ºå·¥å…·ï¼ˆæœ€ç»ˆä¼˜åŒ–ç‰ˆï¼‰</h1>
        
        <!-- é…ç½®é¢æ¿ï¼ˆå¯æŠ˜å ï¼‰ -->
        <div class="bg-white rounded-lg shadow-md mb-6">
            <div class="flex items-center justify-between p-4 cursor-pointer select-none border-b" id="configPanelHeader">
                <h2 class="text-xl font-semibold text-gray-700">é…ç½®é¢æ¿</h2>
                <span class="text-gray-500 text-xl transition-transform" id="configPanelToggle">â–¼</span>
            </div>
            <div id="configPanelContent" class="p-6">
                <!-- æ“ä½œæ§åˆ¶ -->
                <div class="mb-4">
                    <h3 class="text-lg font-medium text-gray-600 mb-2">æ“ä½œæ§åˆ¶</h3>
                    <div class="flex flex-wrap gap-3">
                        <button id="addHiddenLayer" class="bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded-lg transition-colors">
                            æ–°å¢éšè—å±‚ç»„ï¼ˆz/aä¸¤å±‚ï¼‰
                        </button>
                        <button id="addSingleHiddenLayer" class="bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg transition-colors">
                            æ–°å¢å•å±‚éšè—å±‚
                        </button>
                        <button id="toggleAllParams" class="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg transition-colors">
                            éšè—æ‰€æœ‰å‚æ•°
                        </button>
                        <button id="toggleAllWeights" class="bg-yellow-500 hover:bg-yellow-600 text-white py-2 px-4 rounded-lg transition-colors">
                            æ˜¾ç¤ºæ‰€æœ‰æƒé‡
                        </button>
                        <button id="refreshView" class="bg-purple-600 hover:bg-purple-700 text-white py-2 px-4 rounded-lg transition-colors">
                            åˆ·æ–°å¯è§†åŒ–è§†å›¾
                        </button>
                    </div>
                </div>
                
                <!-- å„å±‚èŠ‚ç‚¹é…ç½® -->
                <div class="mb-2">
                    <h3 class="text-sm font-medium text-gray-600 mb-1">å„å±‚èŠ‚ç‚¹é…ç½®</h3>
                    <div id="layerConfigs" class="space-y-1">
                        <!-- è¾“å…¥å±‚ï¼ˆé»˜è®¤ä¸å¯åˆ é™¤ï¼‰ -->
                        <div class="layer-item flex items-center justify-between py-1 px-2 border rounded-md bg-gray-50">
                            <div class="flex items-center text-sm">
                                <span class="font-medium mr-1">è¾“å…¥å±‚ï¼š</span>
                                <input type="number" class="node-count w-12 p-0.5 border rounded text-center text-sm" value="3" min="1" data-layer-index="0">
                                <span class="ml-1 text-gray-500">èŠ‚ç‚¹</span>
                            </div>
                            <span class="text-xs text-gray-400">é»˜è®¤</span>
                        </div>
                        
                        <!-- è¾“å‡ºå±‚ï¼ˆé»˜è®¤ä¸å¯åˆ é™¤ï¼‰ -->
                        <div class="layer-item flex items-center justify-between py-1 px-2 border rounded-md bg-gray-50">
                            <div class="flex items-center text-sm">
                                <span class="font-medium mr-1">è¾“å‡ºå±‚ï¼š</span>
                                <input type="number" class="node-count w-12 p-0.5 border rounded text-center text-sm" value="1" min="1" data-layer-index="1">
                                <span class="ml-1 text-gray-500">èŠ‚ç‚¹</span>
                            </div>
                            <span class="text-xs text-gray-400">é»˜è®¤</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- å¯è§†åŒ–ç”»å¸ƒåŒºåŸŸ -->
        <div class="bg-white rounded-lg shadow-md p-6">
            <h2 class="text-xl font-semibold text-gray-700 mb-4 text-center">ç¥ç»ç½‘ç»œå¯è§†åŒ–è§†å›¾</h2>
            <div class="flex justify-center">
                <div class="visualization-wrapper">
                    <div id="visualizationContainer" class="visualization-container">
                        <canvas id="neuralNetworkCanvas" width="1200" height="600"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- èŠ‚ç‚¹å‚æ•°å¼¹æ¡†ï¼ˆæ”¯æŒä¸Šä¸‹æ ‡/é¡¶æ ‡ç‹¬ç«‹è¾“å…¥ï¼‰ -->
    <div class="modal-mask" id="modalMask"></div>
    <div class="node-param-modal" id="nodeParamModal">
        <div class="modal-header">
            <h3 class="text-lg font-semibold text-gray-700" id="modalTitle">èŠ‚ç‚¹è‡ªå®šä¹‰å‚æ•°</h3>
            <span class="close-modal" id="closeModal">&times;</span>
        </div>
        <div style="display: flex; gap: 12px; align-items: stretch;">
            <div id="paramList" class="mb-4 max-h-60 overflow-y-auto" style="flex: 1;">
                <div class="text-sm text-gray-500 text-center py-4">è¯¥èŠ‚ç‚¹æ— è‡ªå®šä¹‰å‚æ•°ï¼Œç‚¹å‡»æ–°å¢å‚æ•°</div>
            </div>
            <button id="addNodeParam" class="bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg transition-colors text-sm" style="min-width: 40px; padding: 8px 12px; writing-mode: vertical-rl; text-orientation: upright; letter-spacing: 2px;">
                æ–°å¢
            </button>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡å­˜å‚¨ç¥ç»ç½‘ç»œæ•°æ®ï¼ˆä¼˜åŒ–éšè—å±‚ç»„é€»è¾‘ï¼‰
        const neuralNetworkData = {
            layers: [
                { type: 'input', nodeCount: 3, isDefault: true, nodes: [], isZLayer: false, isALayer: false }, // è¾“å…¥å±‚
                { type: 'output', nodeCount: 1, isDefault: true, nodes: [], isZLayer: false, isALayer: false } // è¾“å‡ºå±‚
            ],
            weights: {} // å­˜å‚¨æƒé‡ w[layerPairIndex][fromNode][toNode]
        };

        // å…¨å±€å˜é‡å­˜å‚¨å½“å‰é€‰ä¸­èŠ‚ç‚¹
        let currentSelectedNode = {
            layerIndex: -1,
            nodeIndex: -1
        };

        // å…¨å±€å˜é‡å­˜å‚¨æƒé‡ä½ç½®ï¼ˆç”¨äºé˜²é‡å åˆ¤æ–­ï¼‰
        let weightPositions = [];
        
        // å…¨å±€å˜é‡å­˜å‚¨èŠ‚ç‚¹å‚æ•°é¢æ¿çš„å›ºå®šçŠ¶æ€
        const pinnedNodes = new Set(); // å­˜å‚¨å›ºå®šçš„èŠ‚ç‚¹ID: "layerIndex,nodeIndex"
        
        // å­˜å‚¨å‚æ•°é¢æ¿çš„è‡ªå®šä¹‰ä½ç½® { "layerIndex,nodeIndex": { x, y } }
        const panelPositions = {};
        
        // å­˜å‚¨å‚æ•°é¢æ¿çš„æŠ˜å çŠ¶æ€
        const collapsedNodes = new Set();
        
        // å…¨å±€å‚æ•°æ˜¾ç¤ºçŠ¶æ€
        let showAllParamsMode = true;
        
        // å½“å‰æ‚¬æµ®çš„èŠ‚ç‚¹
        let currentHoverNode = null;
        
        // å»¶è¿Ÿéšè—å®šæ—¶å™¨
        let hideTimeout = null;
        
        // æ‹–åŠ¨çŠ¶æ€
        let isDraggingPanel = false;
        let dragPanel = null;
        let dragOffset = { x: 0, y: 0 };

        // DOM å…ƒç´ è·å–
        const addHiddenLayerBtn = document.getElementById('addHiddenLayer');
        const layerConfigs = document.getElementById('layerConfigs');
        const canvas = document.getElementById('neuralNetworkCanvas');
        const ctx = canvas.getContext('2d');
        const visualizationContainer = document.getElementById('visualizationContainer');
        const paramList = document.getElementById('paramList');
        const addNodeParamBtn = document.getElementById('addNodeParam');
        const nodeParamModal = document.getElementById('nodeParamModal');
        const modalMask = document.getElementById('modalMask');
        const closeModal = document.getElementById('closeModal');
        const modalTitle = document.getElementById('modalTitle');

        // å¸ƒå±€å‚æ•°ï¼ˆè‡ªé€‚åº”ç´§å‡‘å¸ƒå±€ï¼Œé˜²æº¢å‡ºï¼‰
        const layoutParams = {
            canvasPadding: 60, // å‡å°è¾¹è·
            nodeRadius: 18, // ç¨å¾®å‡å°èŠ‚ç‚¹åŠå¾„
            layerWidth: 0,
            verticalSpacingBase: 50, // å‡å°åŸºç¡€å‚ç›´é—´è·
            baseLayerWidth: 140, // å‡å°åŸºç¡€å±‚é—´è·ï¼Œæ›´ç´§å‡‘
            minLayerWidth: 100, // æœ€å°å±‚é—´è·
            minVerticalSpacing: 45, // æœ€å°å‚ç›´é—´è·
            weightPositionRatio: 0.5, // æƒé‡é»˜è®¤æ˜¾ç¤ºåœ¨è¿æ¥çº¿çš„50%ä½ç½®
            weightBoxWidth: 60, // ç¨å¾®å‡å°æƒé‡è¾“å…¥æ¡†å®½åº¦
            weightBoxHeight: 18, // ç¨å¾®å‡å°æƒé‡è¾“å…¥æ¡†é«˜åº¦
            weightOverlapTolerance: 20, // æƒé‡é‡å åˆ¤æ–­é˜ˆå€¼
            paramVerticalGap: 20, // å‚æ•°å‚ç›´é—´è·
            paramNodeOffset: 22, // å‚æ•°ä¸èŠ‚ç‚¹é—´è·
            hiddenLayerSplitGap: 0.8, // éšè—å±‚z/aæ‹†åˆ†çš„é—´è·æ¯”ä¾‹
            // åŠ¨æ€è°ƒæ•´å‚æ•°
            dynamicLayerWidthMultiplier: 1.0, // å±‚é—´è·åŠ¨æ€å€æ•°
            dynamicVerticalMultiplier: 1.0, // å‚ç›´é—´è·åŠ¨æ€å€æ•°
        };

        // åˆå§‹åŒ–é¡µé¢
        window.onload = function() {
            initNodeCustomParams();
            initEventListeners();
            // é»˜è®¤ä¸æ·»åŠ éšè—å±‚ï¼Œç”¨æˆ·éœ€è¦æ—¶è‡ªå·±æ·»åŠ 
            initializeWeights();
            drawNeuralNetwork();
        };

        // åˆå§‹åŒ–èŠ‚ç‚¹è‡ªå®šä¹‰å‚æ•°ï¼ˆæ–°å¢ä¸Šä¸‹æ ‡/é¡¶æ ‡å­—æ®µï¼‰
        function initNodeCustomParams() {
            neuralNetworkData.layers.forEach((layer, layerIndex) => {
                layer.nodes = [];
                for (let nodeIndex = 0; nodeIndex < layer.nodeCount; nodeIndex++) {
                    layer.nodes.push({
                        customParams: [], // å­˜å‚¨å˜é‡åå‚æ•°ï¼š[{ base: 'y', sup: '(1)', sub: '22', hat: false, bar: false, value: '0' }, ...]
                        nodeIndex: nodeIndex,
                        layerIndex: layerIndex
                    });
                }
            });
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨ï¼ˆæ•´åˆæ‰€æœ‰æ–°åŠŸèƒ½ï¼‰
        function initEventListeners() {
            // 0. é…ç½®é¢æ¿æŠ˜å åŠŸèƒ½
            const configPanelHeader = document.getElementById('configPanelHeader');
            const configPanelContent = document.getElementById('configPanelContent');
            const configPanelToggle = document.getElementById('configPanelToggle');
            configPanelHeader.addEventListener('click', function() {
                const isCollapsed = configPanelContent.style.display === 'none';
                configPanelContent.style.display = isCollapsed ? 'block' : 'none';
                configPanelToggle.style.transform = isCollapsed ? 'rotate(0deg)' : 'rotate(-90deg)';
            });
            
            // 1. æ–°å¢éšè—å±‚ç»„ï¼ˆä¸€æ¬¡æ€§è¿½åŠ z/aä¸¤å±‚ï¼ŒæŒ‰ç»„ç¼–å·ï¼‰
            addHiddenLayerBtn.addEventListener('click', addHiddenLayerGroup);
            
            // 1.1 æ–°å¢å•å±‚éšè—å±‚
            const addSingleHiddenLayerBtn = document.getElementById('addSingleHiddenLayer');
            addSingleHiddenLayerBtn.addEventListener('click', addSingleHiddenLayer);
            
            // 1.2 æ˜¾ç¤º/éšè—æ‰€æœ‰å‚æ•°
            const toggleAllParamsBtn = document.getElementById('toggleAllParams');
            toggleAllParamsBtn.addEventListener('click', toggleAllParams);
            
            // 1.2.1 æ˜¾ç¤º/éšè—æ‰€æœ‰æƒé‡
            const toggleAllWeightsBtn = document.getElementById('toggleAllWeights');
            toggleAllWeightsBtn.addEventListener('click', toggleAllWeights);
            
            // 1.3 åˆ·æ–°å¯è§†åŒ–è§†å›¾
            const refreshViewBtn = document.getElementById('refreshView');
            refreshViewBtn.addEventListener('click', drawNeuralNetwork);

            // 5. ç›‘å¬èŠ‚ç‚¹æ•°è¾“å…¥å˜åŒ–
            layerConfigs.addEventListener('change', function(e) {
                if (e.target.classList.contains('node-count')) {
                    updateLayerNodeCount(e.target);
                    initNodeCustomParams();
                    drawNeuralNetwork();
                }
            });

            // 6. ç›‘å¬åˆ é™¤éšè—å±‚äº‹ä»¶
            layerConfigs.addEventListener('click', function(e) {
                if (e.target.classList.contains('delete-layer')) {
                    deleteHiddenLayerGroup(e.target);
                    initNodeCustomParams();
                    drawNeuralNetwork();
                } else if (e.target.classList.contains('delete-single-layer')) {
                    deleteSingleHiddenLayer(e.target);
                    initNodeCustomParams();
                    drawNeuralNetwork();
                }
            });

            // 7. ç‚¹å‡»Canvasè¯†åˆ«é€‰ä¸­èŠ‚ç‚¹
            canvas.addEventListener('click', function(e) {
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                selectNodeByClick(clickX, clickY);
            });

            // 8. å…³é—­å¼¹æ¡†äº‹ä»¶
            closeModal.addEventListener('click', closeNodeParamModal);
            modalMask.addEventListener('click', closeNodeParamModal);

            // 9. æ·»åŠ èŠ‚ç‚¹å‚æ•°äº‹ä»¶ï¼ˆæ”¯æŒä¸Šä¸‹æ ‡/é¡¶æ ‡ï¼‰
            addNodeParamBtn.addEventListener('click', addNodeParam);

            // 10. å§”æ‰˜å¤„ç†å‚æ•°ç¼–è¾‘å’Œåˆ é™¤äº‹ä»¶ï¼ˆä½¿ç”¨ input äº‹ä»¶å®ç°å®æ—¶æ›´æ–°ï¼‰
            paramList.addEventListener('input', function(e) {
                if (e.target.classList.contains('param-base-input') || 
                    e.target.classList.contains('param-sup-input') || 
                    e.target.classList.contains('param-sub-input') ||
                    e.target.classList.contains('edit-param-value')) {
                    updateNodeParam(e.target);
                }
            });
            // checkbox ä½¿ç”¨ change äº‹ä»¶
            paramList.addEventListener('change', function(e) {
                if (e.target.classList.contains('param-hat-checkbox')) {
                    updateNodeParam(e.target);
                }
            });
            paramList.addEventListener('click', function(e) {
                if (e.target.classList.contains('delete-param')) {
                    deleteNodeParam(e.target);
                }
            });
            
            // 11. ç›‘å¬Canvasé¼ æ ‡ç§»åŠ¨äº‹ä»¶ï¼ˆç”¨äºæ‚¬æµ®æ˜¾ç¤ºå‚æ•°é¢æ¿å’Œæƒé‡æ ‡ç­¾ï¼‰
            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                handleNodeHover(mouseX, mouseY);
                handleConnectionHover(mouseX, mouseY);
            });
            
            // 12. ç›‘å¬Canvasé¼ æ ‡ç¦»å¼€äº‹ä»¶
            canvas.addEventListener('mouseleave', function() {
                hideHoverParamPanel();
                hideAllWeightContainers();
            });
            
            // 13. å…¨å±€é¼ æ ‡ç§»åŠ¨äº‹ä»¶ - å¤„ç†é¢æ¿æ‹–åŠ¨
            document.addEventListener('mousemove', function(e) {
                if (!isDraggingPanel || !dragPanel) return;
                
                const containerRect = visualizationContainer.getBoundingClientRect();
                const newX = e.clientX - containerRect.left - dragOffset.x;
                const newY = e.clientY - containerRect.top - dragOffset.y;
                
                dragPanel.style.left = `${newX}px`;
                dragPanel.style.top = `${newY}px`;
            });
            
            // 14. å…¨å±€é¼ æ ‡æ¾å¼€äº‹ä»¶ - ç»“æŸæ‹–åŠ¨å¹¶ä¿å­˜ä½ç½®
            document.addEventListener('mouseup', function(e) {
                if (!isDraggingPanel || !dragPanel) return;
                
                const nodeId = dragPanel.dataset.nodeId;
                const containerRect = visualizationContainer.getBoundingClientRect();
                
                // ä¿å­˜ä½ç½®
                panelPositions[nodeId] = {
                    x: e.clientX - containerRect.left - dragOffset.x,
                    y: e.clientY - containerRect.top - dragOffset.y
                };
                
                isDraggingPanel = false;
                dragPanel = null;
            });
            
            // 15. ç”»å¸ƒæ‹–åŠ¨åŠŸèƒ½ - é¼ æ ‡å·¦é”®æ‹–åŠ¨æŸ¥çœ‹éšè—éƒ¨åˆ†
            let isCanvasDragging = false;
            let canvasDragStart = { x: 0, y: 0 };
            let scrollStart = { x: 0, y: 0 };
            const visualWrapper = document.querySelector('.visualization-wrapper');
            
            visualizationContainer.addEventListener('mousedown', function(e) {
                // åªå“åº”å·¦é”®
                if (e.button !== 0) return;
                
                // å¦‚æœç‚¹å‡»çš„æ˜¯è¾“å…¥æ¡†ï¼Œä¸å¯ç”¨æ‹–åŠ¨ï¼Œè®©è¾“å…¥æ¡†æ­£å¸¸è·å¾—ç„¦ç‚¹
                if (e.target.tagName === 'INPUT') return;
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åœ¨èŠ‚ç‚¹ä¸Š
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                let clickedOnNode = false;
                neuralNetworkData.layers.forEach(layer => {
                    layer.nodes.forEach(node => {
                        if (node.x && node.y) {
                            const dx = clickX - node.x;
                            const dy = clickY - node.y;
                            if (Math.sqrt(dx * dx + dy * dy) <= layoutParams.nodeRadius) {
                                clickedOnNode = true;
                            }
                        }
                    });
                });
                
                // å¦‚æœç‚¹å‡»åœ¨èŠ‚ç‚¹ä¸Šï¼Œä¸å¯ç”¨æ‹–åŠ¨
                if (clickedOnNode) return;
                
                isCanvasDragging = true;
                canvasDragStart = { x: e.clientX, y: e.clientY };
                scrollStart = { x: visualWrapper.scrollLeft, y: visualWrapper.scrollTop };
                document.body.style.cursor = 'grabbing';
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
                e.stopPropagation();
            });
            
            // ä½¿ç”¨ document ç›‘å¬ mousemoveï¼Œè¿™æ ·é¼ æ ‡ç§»å‡º canvas ä¹Ÿèƒ½ç»§ç»­æ‹–åŠ¨
            document.addEventListener('mousemove', function(e) {
                if (!isCanvasDragging) return;
                
                const dx = e.clientX - canvasDragStart.x;
                const dy = e.clientY - canvasDragStart.y;
                
                visualWrapper.scrollLeft = scrollStart.x - dx;
                visualWrapper.scrollTop = scrollStart.y - dy;
                
                e.preventDefault();
            });
            
            document.addEventListener('mouseup', function() {
                if (isCanvasDragging) {
                    isCanvasDragging = false;
                    document.body.style.cursor = '';
                    canvas.style.cursor = 'grab';
                }
            });
        }

        // ç‚¹å‡»Canvasè¯†åˆ«é€‰ä¸­èŠ‚ç‚¹
        function selectNodeByClick(clickX, clickY) {
            const layers = neuralNetworkData.layers;
            let selected = false;

            layers.forEach((layer, layerIndex) => {
                if (selected) return;
                const node = layer.nodes.find((n, nodeIndex) => {
                    if (!n.x || !n.y) return false;
                    const dx = clickX - n.x;
                    const dy = clickY - n.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance <= layoutParams.nodeRadius;
                });
                
                if (node) {
                    const nodeIndex = layer.nodes.indexOf(node);
                    currentSelectedNode = {
                        layerIndex: layerIndex,
                        nodeIndex: nodeIndex
                    };
                    // ç”Ÿæˆå±‚åç§°
                    let layerName = '';
                    if (layer.type === 'input') {
                        layerName = 'è¾“å…¥å±‚';
                    } else if (layer.type === 'output') {
                        layerName = 'è¾“å‡ºå±‚';
                    } else if (layer.isZLayer) {
                        const groupIndex = layer.groupIndex || Math.floor((layerIndex - 1) / 2) + 1;
                        layerName = `éšè—å±‚ ${groupIndex}-z`;
                    } else if (layer.isALayer) {
                        const groupIndex = layer.groupIndex || Math.floor((layerIndex - 1) / 2) + 1;
                        layerName = `éšè—å±‚ ${groupIndex}-a`;
                    } else if (layer.isSingleLayer) {
                        layerName = `éšè—å±‚ ${layer.singleLayerIndex}`;
                    }
                    modalTitle.textContent = `${layerName} - èŠ‚ç‚¹ ${nodeIndex + 1} è‡ªå®šä¹‰å‚æ•°`;
                    renderNodeParamList();
                    openNodeParamModal();
                    selected = true;
                }
            });
        }
        
        // å¤„ç†èŠ‚ç‚¹æ‚¬æµ®äº‹ä»¶
        function handleNodeHover(mouseX, mouseY) {
            const layers = neuralNetworkData.layers;
            let foundNode = null;
            
            layers.forEach((layer, layerIndex) => {
                if (foundNode) return;
                layer.nodes.forEach((node, nodeIndex) => {
                    if (foundNode) return;
                    if (!node.x || !node.y) return;
                    const dx = mouseX - node.x;
                    const dy = mouseY - node.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= layoutParams.nodeRadius) {
                        foundNode = { layerIndex, nodeIndex };
                    }
                });
            });
            
            if (foundNode) {
                const nodeId = `${foundNode.layerIndex},${foundNode.nodeIndex}`;
                // æ¸…é™¤éšè—å®šæ—¶å™¨
                if (hideTimeout) {
                    clearTimeout(hideTimeout);
                    hideTimeout = null;
                }
                if (currentHoverNode !== nodeId) {
                    // éšè—ä¹‹å‰æ‚¬æµ®çš„èŠ‚ç‚¹å‚æ•°é¢æ¿ï¼ˆå¦‚æœæ²¡æœ‰å›ºå®šï¼‰
                    hideHoverParamPanelImmediate();
                    currentHoverNode = nodeId;
                    showNodeParamPanel(foundNode.layerIndex, foundNode.nodeIndex);
                }
            } else {
                // å»¶è¿Ÿéšè—ï¼Œç»™ç”¨æˆ·æ—¶é—´ç§»åŠ¨åˆ°å‚æ•°é¢æ¿ä¸Š
                scheduleHideParamPanel();
            }
        }
        
        // æ˜¾ç¤ºèŠ‚ç‚¹å‚æ•°é¢æ¿
        function showNodeParamPanel(layerIndex, nodeIndex) {
            const nodeId = `${layerIndex},${nodeIndex}`;
            const panel = visualizationContainer.querySelector(`.node-param-group[data-node-id="${nodeId}"]`);
            if (panel && !panel.classList.contains('pinned')) {
                panel.classList.add('visible');
            }
        }
        
        // å»¶è¿Ÿéšè—å‚æ•°é¢æ¿
        function scheduleHideParamPanel() {
            if (hideTimeout) {
                clearTimeout(hideTimeout);
            }
            hideTimeout = setTimeout(() => {
                hideHoverParamPanelImmediate();
                hideTimeout = null;
            }, 200); // 200ms å»¶è¿Ÿï¼Œç»™ç”¨æˆ·è¶³å¤Ÿæ—¶é—´ç§»åŠ¨åˆ°é¢æ¿ä¸Š
        }
        
        // ç«‹å³éšè—æ‚¬æµ®çš„å‚æ•°é¢æ¿ï¼ˆä¸å½±å“å›ºå®šçš„é¢æ¿å’Œæ­£åœ¨æ‚¬æµ®çš„é¢æ¿ï¼‰
        function hideHoverParamPanelImmediate() {
            if (currentHoverNode) {
                const panel = visualizationContainer.querySelector(`.node-param-group[data-node-id="${currentHoverNode}"]`);
                if (panel && !panel.classList.contains('pinned') && !panel.classList.contains('hover-active')) {
                    panel.classList.remove('visible');
                }
                currentHoverNode = null;
            }
        }
        
        // éšè—æ‚¬æµ®çš„å‚æ•°é¢æ¿ï¼ˆå¸¦å»¶è¿Ÿï¼‰
        function hideHoverParamPanel() {
            scheduleHideParamPanel();
        }
        
        // å­˜å‚¨æ‰€æœ‰è¿æ¥çº¿ä¿¡æ¯ï¼ˆç”¨äºæ‚¬æµ®æ£€æµ‹ï¼‰
        let connectionLines = [];
        
        // å¤„ç†è¿æ¥çº¿æ‚¬æµ®äº‹ä»¶
        function handleConnectionHover(mouseX, mouseY) {
            // å¦‚æœå·²å¼€å¯æ˜¾ç¤ºæ‰€æœ‰æƒé‡æ¨¡å¼ï¼Œä¸å¤„ç†æ‚¬æµ®
            if (showAllWeightsMode) return;
            
            const threshold = 8; // é¼ æ ‡è·ç¦»è¿æ¥çº¿çš„é˜ˆå€¼ï¼ˆåƒç´ ï¼‰
            let foundConnection = null;
            
            connectionLines.forEach(conn => {
                if (foundConnection) return;
                const dist = pointToLineDistance(mouseX, mouseY, conn.prevPos.x, conn.prevPos.y, conn.currentPos.x, conn.currentPos.y);
                if (dist <= threshold) {
                    foundConnection = conn;
                }
            });
            
            // éšè—æ‰€æœ‰æƒé‡å®¹å™¨
            hideAllWeightContainers();
            
            // æ˜¾ç¤ºæ‚¬æµ®çš„è¿æ¥çº¿å¯¹åº”çš„æƒé‡å®¹å™¨
            if (foundConnection) {
                const containerId = `${foundConnection.layerPairIndex},${foundConnection.fromNode},${foundConnection.toNode}`;
                const container = visualizationContainer.querySelector(`.weight-container[data-id="${containerId}"]`);
                if (container) {
                    container.classList.add('visible');
                }
            }
        }
        
        // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) {
                param = dot / lenSq;
            }
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // éšè—æ‰€æœ‰æƒé‡å®¹å™¨
        function hideAllWeightContainers() {
            // å¦‚æœå·²å¼€å¯æ˜¾ç¤ºæ‰€æœ‰æƒé‡æ¨¡å¼ï¼Œä¸éšè—
            if (showAllWeightsMode) return;
            
            const containers = visualizationContainer.querySelectorAll('.weight-container');
            containers.forEach(container => {
                container.classList.remove('visible');
            });
        }
        
        // åˆ‡æ¢èŠ‚ç‚¹å‚æ•°é¢æ¿çš„å›ºå®šçŠ¶æ€
        function togglePinNode(layerIndex, nodeIndex) {
            const nodeId = `${layerIndex},${nodeIndex}`;
            const panel = visualizationContainer.querySelector(`.node-param-group[data-node-id="${nodeId}"]`);
            const pinIcon = panel ? panel.querySelector('.pin-icon') : null;
            
            if (pinnedNodes.has(nodeId)) {
                pinnedNodes.delete(nodeId);
                if (panel) {
                    panel.classList.remove('pinned');
                    panel.classList.remove('visible');
                }
                if (pinIcon) {
                    pinIcon.classList.remove('pinned');
                    pinIcon.textContent = 'ğŸ“Œ';
                }
            } else {
                pinnedNodes.add(nodeId);
                if (panel) {
                    panel.classList.add('pinned');
                }
                if (pinIcon) {
                    pinIcon.classList.add('pinned');
                    pinIcon.textContent = 'ğŸ“';
                }
            }
        }

        // æ‰“å¼€èŠ‚ç‚¹å‚æ•°å¼¹æ¡†
        function openNodeParamModal() {
            nodeParamModal.classList.add('active');
            modalMask.classList.add('active');
        }

        // å…³é—­èŠ‚ç‚¹å‚æ•°å¼¹æ¡†
        function closeNodeParamModal() {
            nodeParamModal.classList.remove('active');
            modalMask.classList.remove('active');
            currentSelectedNode = {
                layerIndex: -1,
                nodeIndex: -1
            };
            // å…³é—­å¼¹æ¡†æ—¶é‡æ–°æ¸²æŸ“è§†å›¾å’Œå‚æ•°åˆ—è¡¨
            drawNeuralNetwork();
        }

        // æ–°å¢éšè—å±‚ç»„ï¼ˆä¸€æ¬¡æ€§è¿½åŠ z/aä¸¤å±‚ï¼Œä¸¥æ ¼æŒ‰ç»„ç¼–å·ï¼šéšè—å±‚1-z/aã€éšè—å±‚2-z/a...ï¼‰
        function addHiddenLayerGroup() {
            // è®¡ç®—å½“å‰æ‰€æœ‰éšè—å±‚çš„æœ€å¤§ç¼–å·ï¼ˆå•å±‚å’Œéšè—å±‚ç»„å…±ç”¨ç¼–å·åºåˆ—ï¼‰
            let maxHiddenIndex = 0;
            neuralNetworkData.layers.forEach(layer => {
                if (layer.type === 'hidden' && !layer.isDefault) {
                    if (layer.isSingleLayer && layer.singleLayerIndex > maxHiddenIndex) {
                        maxHiddenIndex = layer.singleLayerIndex;
                    } else if (layer.groupIndex && layer.groupIndex > maxHiddenIndex) {
                        maxHiddenIndex = layer.groupIndex;
                    }
                }
            });
            const newGroupIndex = maxHiddenIndex + 1;
            const insertIndex = neuralNetworkData.layers.length - 1; // æ’å…¥åˆ°è¾“å‡ºå±‚å‰

            // 1. åˆ›å»ºzå±‚ï¼ˆè™šçº¿èŠ‚ç‚¹ï¼Œéšè—å±‚newGroupIndex-zï¼‰
            const hiddenLayerZ = {
                type: 'hidden',
                nodeCount: 2,
                isDefault: false,
                nodes: [],
                isZLayer: true,
                isALayer: false,
                groupIndex: newGroupIndex
            };
            // åˆå§‹åŒ–zå±‚èŠ‚ç‚¹å‚æ•°
            for (let nodeIndex = 0; nodeIndex < hiddenLayerZ.nodeCount; nodeIndex++) {
                hiddenLayerZ.nodes.push({
                    customParams: [],
                    nodeIndex: nodeIndex,
                    layerIndex: insertIndex
                });
            }

            // 2. åˆ›å»ºaå±‚ï¼ˆå®çº¿èŠ‚ç‚¹ï¼Œéšè—å±‚newGroupIndex-aï¼‰
            const hiddenLayerA = {
                type: 'hidden',
                nodeCount: 2,
                isDefault: false,
                nodes: [],
                isZLayer: false,
                isALayer: true,
                groupIndex: newGroupIndex
            };
            // åˆå§‹åŒ–aå±‚èŠ‚ç‚¹å‚æ•°
            for (let nodeIndex = 0; nodeIndex < hiddenLayerA.nodeCount; nodeIndex++) {
                hiddenLayerA.nodes.push({
                    customParams: [],
                    nodeIndex: nodeIndex,
                    layerIndex: insertIndex + 1
                });
            }

            // 3. ä¸€æ¬¡æ€§æ’å…¥z/aä¸¤å±‚ï¼ˆæŒ‰ç»„æ’å…¥ï¼Œä¿è¯ç¼–å·è¿ç»­ï¼‰
            neuralNetworkData.layers.splice(insertIndex, 0, hiddenLayerZ, hiddenLayerA);
            renderLayerConfigs();
            initializeWeights();
            drawNeuralNetwork();
        }
        
        // æ–°å¢å•å±‚éšè—å±‚
        function addSingleHiddenLayer() {
            // è®¡ç®—å½“å‰æ‰€æœ‰éšè—å±‚çš„æœ€å¤§ç¼–å·ï¼ˆå•å±‚å’Œéšè—å±‚ç»„å…±ç”¨ç¼–å·åºåˆ—ï¼‰
            let maxHiddenIndex = 0;
            neuralNetworkData.layers.forEach(layer => {
                if (layer.type === 'hidden' && !layer.isDefault) {
                    if (layer.isSingleLayer && layer.singleLayerIndex > maxHiddenIndex) {
                        maxHiddenIndex = layer.singleLayerIndex;
                    } else if (layer.groupIndex && layer.groupIndex > maxHiddenIndex) {
                        maxHiddenIndex = layer.groupIndex;
                    }
                }
            });
            const newSingleIndex = maxHiddenIndex + 1;
            const insertIndex = neuralNetworkData.layers.length - 1; // æ’å…¥åˆ°è¾“å‡ºå±‚å‰

            // åˆ›å»ºå•å±‚éšè—å±‚
            const singleHiddenLayer = {
                type: 'hidden',
                nodeCount: 2,
                isDefault: false,
                nodes: [],
                isZLayer: false,
                isALayer: false,
                isSingleLayer: true,
                singleLayerIndex: newSingleIndex
            };
            
            // åˆå§‹åŒ–èŠ‚ç‚¹å‚æ•°
            for (let nodeIndex = 0; nodeIndex < singleHiddenLayer.nodeCount; nodeIndex++) {
                singleHiddenLayer.nodes.push({
                    customParams: [],
                    nodeIndex: nodeIndex,
                    layerIndex: insertIndex
                });
            }

            neuralNetworkData.layers.splice(insertIndex, 0, singleHiddenLayer);
            renderLayerConfigs();
            initializeWeights();
            drawNeuralNetwork();
        }

        // æ¸²æŸ“å„å±‚é…ç½®DOM
        function renderLayerConfigs() {
            const inputLayerDom = layerConfigs.children[0];
            const outputLayerDom = layerConfigs.children[layerConfigs.children.length - 1];
            layerConfigs.innerHTML = '';
            layerConfigs.appendChild(inputLayerDom);

            // æŸ¥æ‰¾æ‰€æœ‰éšè—å±‚ç»„å’Œå•å±‚éšè—å±‚
            const hiddenGroups = {};
            const singleLayers = [];
            
            neuralNetworkData.layers.forEach((layer, idx) => {
                if (layer.type === 'hidden' && !layer.isDefault) {
                    if (layer.isSingleLayer) {
                        singleLayers.push({ layer, idx });
                    } else {
                        const groupIndex = layer.groupIndex;
                        if (!hiddenGroups[groupIndex]) {
                            hiddenGroups[groupIndex] = { zLayer: null, aLayer: null };
                        }
                        if (layer.isZLayer) {
                            hiddenGroups[groupIndex].zLayer = layer;
                        } else if (layer.isALayer) {
                            hiddenGroups[groupIndex].aLayer = layer;
                        }
                    }
                }
            });

            // æŒ‰ç»„ç¼–å·æ­£åºæ¸²æŸ“éšè—å±‚ç»„
            const sortedGroupIndexes = Object.keys(hiddenGroups).sort((a, b) => a - b);
            sortedGroupIndexes.forEach(groupIndex => {
                const group = hiddenGroups[groupIndex];
                if (group.zLayer && group.aLayer) {
                    const layerDom = document.createElement('div');
                    layerDom.className = 'layer-item flex items-center justify-between py-1 px-2 border rounded-md bg-blue-50';
                    const zLayerIndex = neuralNetworkData.layers.findIndex(l => l === group.zLayer);
                    layerDom.innerHTML = `
                        <div class="flex items-center text-sm">
                            <span class="font-medium mr-1 text-blue-700">éšè—å±‚ç»„${groupIndex}ï¼š</span>
                            <input type="number" class="node-count w-12 p-0.5 border rounded text-center text-sm" value="${group.zLayer.nodeCount}" min="1" data-layer-index="${zLayerIndex}" data-group-index="${groupIndex}">
                            <span class="ml-1 text-gray-500">èŠ‚ç‚¹</span>
                        </div>
                        <button class="delete-layer bg-red-500 hover:bg-red-600 text-white py-0.5 px-2 rounded text-xs transition-colors">
                            åˆ é™¤
                        </button>
                    `;
                    layerDom.querySelector('.delete-layer').dataset.groupIndex = groupIndex;
                    layerConfigs.appendChild(layerDom);

                    // åŒæ­¥aå±‚èŠ‚ç‚¹æ•°ï¼ˆä¸zå±‚ä¿æŒä¸€è‡´ï¼‰
                    group.aLayer.nodeCount = group.zLayer.nodeCount;
                }
            });
            
            // æ¸²æŸ“å•å±‚éšè—å±‚
            singleLayers.forEach(({ layer, idx }) => {
                const layerDom = document.createElement('div');
                layerDom.className = 'layer-item flex items-center justify-between py-1 px-2 border rounded-md bg-green-50';
                const layerIndex = neuralNetworkData.layers.findIndex(l => l === layer);
                layerDom.innerHTML = `
                    <div class="flex items-center text-sm">
                        <span class="font-medium mr-1 text-green-700">å•å±‚${layer.singleLayerIndex}ï¼š</span>
                        <input type="number" class="node-count w-12 p-0.5 border rounded text-center text-sm" value="${layer.nodeCount}" min="1" data-layer-index="${layerIndex}" data-single-index="${layer.singleLayerIndex}">
                        <span class="ml-1 text-gray-500">èŠ‚ç‚¹</span>
                    </div>
                    <button class="delete-single-layer bg-red-500 hover:bg-red-600 text-white py-0.5 px-2 rounded text-xs transition-colors" data-layer-index="${layerIndex}">
                        åˆ é™¤
                    </button>
                `;
                layerConfigs.appendChild(layerDom);
            });

            layerConfigs.appendChild(outputLayerDom);
            // ç¡®ä¿é»˜è®¤å±‚çš„data-layer-indexæ­£ç¡®
            inputLayerDom.querySelector('.node-count').setAttribute('data-layer-index', 0);
            outputLayerDom.querySelector('.node-count').setAttribute('data-layer-index', neuralNetworkData.layers.length - 1);
        }

        // åˆ é™¤å•å±‚éšè—å±‚
        function deleteSingleHiddenLayer(deleteBtn) {
            const layerIndex = parseInt(deleteBtn.getAttribute('data-layer-index'));
            if (layerIndex > 0 && layerIndex < neuralNetworkData.layers.length - 1) {
                neuralNetworkData.layers.splice(layerIndex, 1);
                
                // é‡æ–°æ•´ç†å•å±‚éšè—å±‚çš„ç¼–å·
                let singleIndex = 1;
                neuralNetworkData.layers.forEach(layer => {
                    if (layer.isSingleLayer) {
                        layer.singleLayerIndex = singleIndex++;
                    }
                });
                
                renderLayerConfigs();
                initializeWeights();
            }
        }

        // æ›´æ–°å±‚èŠ‚ç‚¹æ•°ï¼ˆz/aå±‚åŒæ­¥æ›´æ–°ï¼Œç®€åŒ–é€»è¾‘ï¼‰
        function updateLayerNodeCount(inputElement) {
            const layerIndex = parseInt(inputElement.getAttribute('data-layer-index'));
            const groupIndex = inputElement.getAttribute('data-group-index');
            const newNodeCount = Math.max(1, parseInt(inputElement.value) || 1);

            if (neuralNetworkData.layers[layerIndex]) {
                // æ›´æ–°å½“å‰å±‚èŠ‚ç‚¹æ•°
                neuralNetworkData.layers[layerIndex].nodeCount = newNodeCount;
                // åŒæ­¥å¯¹åº”åˆ†ç»„çš„å¦ä¸€å±‚ï¼ˆz/aå±‚ï¼‰
                if (groupIndex) {
                    const groupLayers = neuralNetworkData.layers.filter(layer => layer.groupIndex == groupIndex);
                    groupLayers.forEach(layer => {
                        layer.nodeCount = newNodeCount;
                    });
                }
                initializeWeights();
            }
        }

        // åˆ é™¤éšè—å±‚ç»„ï¼ˆä¸€æ¬¡æ€§åˆ é™¤z/aä¸¤å±‚ï¼Œä¿æŒç»„ç¼–å·è¿ç»­ï¼‰
        function deleteHiddenLayerGroup(deleteBtn) {
            const groupIndex = deleteBtn.getAttribute('data-group-index');
            // æ‰¾åˆ°è¯¥ç»„çš„æ‰€æœ‰å±‚å¹¶åˆ é™¤
            const groupLayerIndexes = neuralNetworkData.layers
                .map((layer, index) => ({ layer, index }))
                .filter(item => item.layer.groupIndex == groupIndex)
                .map(item => item.index)
                .sort((a, b) => b - a); // å€’åºåˆ é™¤é¿å…ç´¢å¼•é”™ä¹±

            // åˆ é™¤è¯¥ç»„z/aä¸¤å±‚
            groupLayerIndexes.forEach(index => {
                neuralNetworkData.layers.splice(index, 1);
            });

            // é‡æ–°æ•´ç†å‰©ä½™éšè—å±‚ç»„çš„ç¼–å·ï¼ˆä¿è¯è¿ç»­ï¼‰
            const remainingHiddenGroups = {};
            neuralNetworkData.layers.forEach(layer => {
                if (layer.type === 'hidden' && !layer.isDefault) {
                    remainingHiddenGroups[layer.groupIndex] = true;
                }
            });
            const sortedRemainingGroups = Object.keys(remainingHiddenGroups).sort((a, b) => a - b);
            sortedRemainingGroups.forEach((oldGroupIndex, newGroupIndex) => {
                neuralNetworkData.layers.forEach(layer => {
                    if (layer.groupIndex == oldGroupIndex) {
                        layer.groupIndex = newGroupIndex + 1;
                    }
                });
            });

            renderLayerConfigs();
            initializeWeights();
        }

        // åˆå§‹åŒ–æƒé‡
        function initializeWeights() {
            const layers = neuralNetworkData.layers;
            neuralNetworkData.weights = {};

            for (let layerPairIndex = 0; layerPairIndex < layers.length - 1; layerPairIndex++) {
                const prevLayer = layers[layerPairIndex];
                const currentLayer = layers[layerPairIndex + 1];
                neuralNetworkData.weights[layerPairIndex] = [];

                // åˆ¤æ–­æ˜¯å¦æ˜¯z/aå±‚ï¼ˆä»…1:1è¿æ¥ï¼‰
                const isZALayerPair = prevLayer.isZLayer && currentLayer.isALayer;

                for (let fromNode = 0; fromNode < prevLayer.nodeCount; fromNode++) {
                    neuralNetworkData.weights[layerPairIndex][fromNode] = [];
                    // z/aå±‚ä»…1:1è¿æ¥ï¼Œå…¶ä»–å±‚ç¬›å¡å°”ç§¯
                    const toNodeRange = isZALayerPair ? [fromNode] : Array.from({length: currentLayer.nodeCount}, (_, i) => i);
                    
                    toNodeRange.forEach(toNode => {
                        neuralNetworkData.weights[layerPairIndex][fromNode][toNode] = 1; // é»˜è®¤æƒé‡ä¸º1
                    });
                }
            }
            updateEditableInputs();
        }

        // æ¸…ç©ºæ‰€æœ‰å¯ç¼–è¾‘è¾“å…¥æ¡†
        function clearEditableInputs() {
            weightPositions = []; // é‡ç½®æƒé‡ä½ç½®è®°å½•
            const allInputs = visualizationContainer.querySelectorAll('.weight-container, .node-param-container, .node-param-group');
            allInputs.forEach(input => input.remove());
        }

        // æ›´æ–°å¯ç¼–è¾‘è¾“å…¥æ¡†çš„å€¼
        function updateEditableInputs() {
            const weightContainers = visualizationContainer.querySelectorAll('.weight-container');
            weightContainers.forEach(container => {
                const [layerPairIndex, fromNode, toNode] = container.dataset.id.split(',').map(Number);
                // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿æƒé‡æ•°ç»„å­˜åœ¨
                if (neuralNetworkData.weights[layerPairIndex] && 
                    neuralNetworkData.weights[layerPairIndex][fromNode] && 
                    neuralNetworkData.weights[layerPairIndex][fromNode][toNode] !== undefined) {
                    const weightValue = neuralNetworkData.weights[layerPairIndex][fromNode][toNode] || 0;
                    const input = container.querySelector('.weight-input');
                    if (input) input.value = weightValue;
                }
            });
        }

        // æ¸²æŸ“èŠ‚ç‚¹å‚æ•°åˆ—è¡¨ï¼ˆæ”¯æŒåŸºç¡€å+ä¸Šæ ‡+ä¸‹æ ‡+é¡¶æ ‡ï¼‰
        function renderNodeParamList() {
            const { layerIndex, nodeIndex } = currentSelectedNode;
            if (layerIndex === -1 || nodeIndex === -1) {
                paramList.innerHTML = '<div class="text-sm text-gray-500 text-center py-4">è¯¥èŠ‚ç‚¹æ— è‡ªå®šä¹‰å‚æ•°ï¼Œç‚¹å‡»æ–°å¢å‚æ•°</div>';
                return;
            }
            if (!neuralNetworkData.layers[layerIndex] || !neuralNetworkData.layers[layerIndex].nodes[nodeIndex]) {
                paramList.innerHTML = '<div class="text-sm text-gray-500 text-center py-4">è¯¥èŠ‚ç‚¹ä¸å­˜åœ¨</div>';
                return;
            }
            const node = neuralNetworkData.layers[layerIndex].nodes[nodeIndex];
            if (!node.customParams || node.customParams.length === 0) {
                paramList.innerHTML = '<div class="text-sm text-gray-500 text-center py-4">è¯¥èŠ‚ç‚¹æ— è‡ªå®šä¹‰å‚æ•°ï¼Œç‚¹å‡»æ–°å¢å‚æ•°</div>';
                return;
            }
            paramList.innerHTML = '';
            node.customParams.forEach((param, paramIndex) => {
                const paramItem = document.createElement('div');
                paramItem.className = 'param-item';
                paramItem.draggable = true;
                paramItem.dataset.paramIndex = paramIndex;
                paramItem.innerHTML = `
                    <span class="drag-handle" style="cursor: grab; margin-right: 6px; color: #9ca3af;">â‹®â‹®</span>
                    <div class="param-name-group" style="display: flex; align-items: center; gap: 4px; flex-wrap: nowrap;">
                        <input type="text" class="param-base-input" value="${param.base || 'y'}" data-param-index="${paramIndex}" placeholder="åŸºç¡€å" style="width: 35px;">
                        <input type="text" class="param-sup-input" value="${param.sup || ''}" data-param-index="${paramIndex}" placeholder="ä¸Šæ ‡" style="width: 25px;">
                        <input type="text" class="param-sub-input" value="${param.sub || ''}" data-param-index="${paramIndex}" placeholder="ä¸‹æ ‡" style="width: 25px;">
                        <label class="flex items-center" style="white-space: nowrap;">
                            <input type="checkbox" class="param-hat-checkbox" data-param-index="${paramIndex}" ${param.hat ? 'checked' : ''}>
                            <span class="text-xs ml-1">hat</span>
                        </label>
                    </div>
                    <span class="node-param-equal">=</span>
                    <input type="text" class="edit-param-value" value="${param.value}" data-param-index="${paramIndex}" style="width: 80px;">
                    <button class="delete-param bg-red-500 hover:bg-red-600 text-white py-1 px-2 rounded-lg text-xs" data-param-index="${paramIndex}">åˆ é™¤</button>
                `;
                
                // æ‹–åŠ¨æ’åºäº‹ä»¶
                paramItem.addEventListener('dragstart', function(e) {
                    e.dataTransfer.setData('text/plain', paramIndex);
                    this.style.opacity = '0.5';
                });
                paramItem.addEventListener('dragend', function() {
                    this.style.opacity = '1';
                });
                paramItem.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.style.borderTop = '2px solid #3b82f6';
                });
                paramItem.addEventListener('dragleave', function() {
                    this.style.borderTop = '';
                });
                paramItem.addEventListener('drop', function(e) {
                    e.preventDefault();
                    this.style.borderTop = '';
                    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const toIndex = parseInt(this.dataset.paramIndex);
                    if (fromIndex !== toIndex) {
                        reorderParams(fromIndex, toIndex);
                    }
                });
                
                paramList.appendChild(paramItem);
            });
        }

        // æ–°å¢èŠ‚ç‚¹å‚æ•°ï¼ˆæ”¯æŒåŸºç¡€å+ä¸Šæ ‡+ä¸‹æ ‡+é¡¶æ ‡ï¼‰
        function addNodeParam() {
            const { layerIndex, nodeIndex } = currentSelectedNode;
            if (layerIndex === -1 || nodeIndex === -1) {
                alert('è¯·å…ˆç‚¹å‡»é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹ï¼');
                return;
            }
            if (!neuralNetworkData.layers[layerIndex] || !neuralNetworkData.layers[layerIndex].nodes[nodeIndex]) {
                alert('æ‰€é€‰èŠ‚ç‚¹ä¸å­˜åœ¨ï¼');
                return;
            }
            const layer = neuralNetworkData.layers[layerIndex];
            const node = layer.nodes[nodeIndex];
            
            // è®¡ç®—é€»è¾‘å±‚ç¼–å·ï¼ˆä¸Šæ ‡ï¼‰
            let logicalLayerIndex = '';
            if (layer.type === 'input') {
                logicalLayerIndex = '0';
            } else if (layer.type === 'output') {
                // è¾“å‡ºå±‚çš„é€»è¾‘å±‚ç¼–å· = æœ€åä¸€ä¸ªéšè—å±‚ç¼–å· + 1
                let maxHiddenIndex = 0;
                neuralNetworkData.layers.forEach(l => {
                    if (l.type === 'hidden' && !l.isDefault) {
                        if (l.isSingleLayer && l.singleLayerIndex > maxHiddenIndex) {
                            maxHiddenIndex = l.singleLayerIndex;
                        } else if (l.groupIndex && l.groupIndex > maxHiddenIndex) {
                            maxHiddenIndex = l.groupIndex;
                        }
                    }
                });
                logicalLayerIndex = String(maxHiddenIndex + 1);
            } else if (layer.isZLayer || layer.isALayer) {
                logicalLayerIndex = String(layer.groupIndex);
            } else if (layer.isSingleLayer) {
                logicalLayerIndex = String(layer.singleLayerIndex);
            }
            
            // ä¸‹æ ‡ä¸ºèŠ‚ç‚¹åœ¨å½“å‰å±‚çš„ä½ç½®ï¼ˆä»1å¼€å§‹ï¼‰
            const nodePosition = String(nodeIndex + 1);
            
            node.customParams.push({
                base: 'b',
                sup: logicalLayerIndex,
                sub: nodePosition,
                hat: false,
                value: '0'
            });
            renderNodeParamList();
            // drawNeuralNetwork(); // ç§»é™¤è‡ªåŠ¨é‡æ–°æ¸²æŸ“ï¼Œåœ¨å…³é—­å¼¹æ¡†æ—¶å†æ¸²æŸ“
        }
        
        // é‡æ–°æ’åºå‚æ•°
        function reorderParams(fromIndex, toIndex) {
            const { layerIndex, nodeIndex } = currentSelectedNode;
            if (layerIndex === -1 || nodeIndex === -1) return;
            const node = neuralNetworkData.layers[layerIndex].nodes[nodeIndex];
            if (!node.customParams) return;
            
            const params = node.customParams;
            const [movedParam] = params.splice(fromIndex, 1);
            params.splice(toIndex, 0, movedParam);
            renderNodeParamList();
        }

        // æ›´æ–°èŠ‚ç‚¹å‚æ•°ï¼ˆæ”¯æŒåŸºç¡€å+ä¸Šæ ‡+ä¸‹æ ‡+é¡¶æ ‡ï¼‰
        function updateNodeParam(inputElement) {
            const { layerIndex, nodeIndex } = currentSelectedNode;
            if (layerIndex === -1 || nodeIndex === -1) return;
            const paramIndex = parseInt(inputElement.dataset.paramIndex);
            if (!neuralNetworkData.layers[layerIndex] || !neuralNetworkData.layers[layerIndex].nodes[nodeIndex] || !neuralNetworkData.layers[layerIndex].nodes[nodeIndex].customParams[paramIndex]) {
                return;
            }
            const node = neuralNetworkData.layers[layerIndex].nodes[nodeIndex];
            const param = node.customParams[paramIndex];
            
            if (inputElement.classList.contains('param-base-input')) {
                param.base = inputElement.value || 'y';
            } else if (inputElement.classList.contains('param-sup-input')) {
                param.sup = inputElement.value;
            } else if (inputElement.classList.contains('param-sub-input')) {
                param.sub = inputElement.value;
            } else if (inputElement.classList.contains('param-hat-checkbox')) {
                param.hat = inputElement.checked;
            } else if (inputElement.classList.contains('edit-param-value')) {
                // å®æ—¶æ›´æ–°æ—¶ä¸æ ¼å¼åŒ–ï¼Œä¿æŒç”¨æˆ·è¾“å…¥
                param.value = inputElement.value;
                // åŒæ­¥æ›´æ–°å‚æ•°æ ‡ç­¾å’Œå‚æ•°å¼¹çª—ä¸­çš„è¾“å…¥æ¡†ï¼ˆä¸é‡å»ºï¼‰
                syncParamValueToLabel(layerIndex, nodeIndex, paramIndex, inputElement.value);
                syncParamValueToPopup(layerIndex, nodeIndex, paramIndex, inputElement.value);
                return; // å€¼ä¿®æ”¹ä¸éœ€è¦é‡å»ºæ ‡ç­¾
            }
            // å…¶ä»–å±æ€§ä¿®æ”¹éœ€è¦æ›´æ–°å‚æ•°æ ‡ç­¾ï¼ˆé‡å»ºï¼‰
            updateParamLabels();
        }
        
        // åŒæ­¥å‚æ•°å€¼åˆ°å¼¹çª—ï¼ˆè‡ªå®šä¹‰å‚æ•°å¼¹çª— + å‚æ•°å¼¹çª—ï¼‰
        function syncParamValueToPopup(layerIndex, nodeIndex, paramIndex, value) {
            // æ›´æ–°è‡ªå®šä¹‰å‚æ•°å¼¹çª—ä¸­çš„è¾“å…¥æ¡†
            const paramList = document.getElementById('nodeParamList');
            if (paramList) {
                const valueInputs = paramList.querySelectorAll('.edit-param-value');
                valueInputs.forEach(input => {
                    if (parseInt(input.dataset.paramIndex) === paramIndex) {
                        if (document.activeElement !== input) {
                            input.value = value;
                        }
                    }
                });
            }
            
            // æ›´æ–°å‚æ•°å¼¹çª—ï¼ˆnode-param-groupï¼‰ä¸­çš„è¾“å…¥æ¡†
            const nodeId = `${layerIndex},${nodeIndex}`;
            const paramGroup = visualizationContainer.querySelector(`.node-param-group[data-node-id="${nodeId}"]`);
            if (paramGroup) {
                const containers = paramGroup.querySelectorAll('.node-param-container');
                containers.forEach(container => {
                    const id = container.dataset.id;
                    if (id === `${layerIndex},${nodeIndex},${paramIndex}`) {
                        const input = container.querySelector('.edit-param-value');
                        if (input && document.activeElement !== input) {
                            input.value = value;
                        }
                    }
                });
            }
        }
        
        // åŒæ­¥å‚æ•°å€¼åˆ°æ ‡ç­¾
        function syncParamValueToLabel(layerIndex, nodeIndex, paramIndex, value) {
            // æ›´æ–°å‚æ•°æ ‡ç­¾ä¸­çš„è¾“å…¥æ¡†
            const labels = document.querySelectorAll('.node-param-label');
            labels.forEach(label => {
                const inputs = label.querySelectorAll('.param-value-input');
                inputs.forEach(input => {
                    if (parseInt(input.dataset.layerIndex) === layerIndex &&
                        parseInt(input.dataset.nodeIndex) === nodeIndex &&
                        parseInt(input.dataset.paramIndex) === paramIndex) {
                        if (document.activeElement !== input) {
                            input.value = value;
                        }
                    }
                });
            });
        }

        // åˆ é™¤èŠ‚ç‚¹å‚æ•°
        function deleteNodeParam(deleteBtn) {
            const { layerIndex, nodeIndex } = currentSelectedNode;
            if (layerIndex === -1 || nodeIndex === -1) return;
            const paramItem = deleteBtn.closest('.param-item');
            if (!paramItem) return;
            const paramIndex = parseInt(paramItem.querySelector('.param-base-input').dataset.paramIndex);
            if (!neuralNetworkData.layers[layerIndex] || !neuralNetworkData.layers[layerIndex].nodes[nodeIndex] || !neuralNetworkData.layers[layerIndex].nodes[nodeIndex].customParams[paramIndex]) {
                return;
            }
            const node = neuralNetworkData.layers[layerIndex].nodes[nodeIndex];
            node.customParams.splice(paramIndex, 1);
            renderNodeParamList(); // åˆ é™¤åéœ€è¦é‡æ–°æ¸²æŸ“å‚æ•°åˆ—è¡¨
            // drawNeuralNetwork(); // ç§»é™¤è‡ªåŠ¨é‡æ–°æ¸²æŸ“ï¼Œåœ¨å…³é—­å¼¹æ¡†æ—¶å†æ¸²æŸ“
        }

        // æ£€æŸ¥æƒé‡ä½ç½®æ˜¯å¦ä¸å·²æœ‰æƒé‡é‡å 
        function checkWeightOverlap(x, y, boxWidth, boxHeight, angle) {
            // è€ƒè™‘æ—‹è½¬åçš„è¾¹ç•Œæ¡†
            const cos = Math.abs(Math.cos(angle));
            const sin = Math.abs(Math.sin(angle));
            const effectiveWidth = boxWidth * cos + boxHeight * sin;
            const effectiveHeight = boxWidth * sin + boxHeight * cos;
            
            for (let i = 0; i < weightPositions.length; i++) {
                const pos = weightPositions[i];
                // ä½¿ç”¨çŸ©å½¢ç¢°æ’æ£€æµ‹
                const dx = Math.abs(x - pos.x);
                const dy = Math.abs(y - pos.y);
                const minDistX = (effectiveWidth + pos.width) / 2;
                const minDistY = (effectiveHeight + pos.height) / 2;
                
                if (dx < minDistX && dy < minDistY) {
                    return true; // å­˜åœ¨é‡å 
                }
            }
            return false; // æ— é‡å 
        }

        // æ²¿è¿æ¥çº¿æ»‘åŠ¨å¯»æ‰¾ä¸é‡å çš„ä½ç½®
        function findNonOverlappingPosition(prevPos, currentPos, initialT, boxWidth, boxHeight) {
            const dx = currentPos.x - prevPos.x;
            const dy = currentPos.y - prevPos.y;
            const lineLength = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            
            // è®¡ç®—æœ‰æ•ˆçš„tèŒƒå›´ï¼ˆç•™å‡ºè¾¹è·ï¼Œé¿å…æƒé‡è¶…å‡ºè¿æ¥çº¿ï¼‰
            const margin = (boxWidth / 2 + 10) / lineLength; // æƒé‡æ¡†åŠå®½ + è¾¹è·
            const minT = Math.max(0.15, margin);
            const maxT = Math.min(0.85, 1 - margin);
            
            // ä»åˆå§‹ä½ç½®å¼€å§‹ï¼Œå‘ä¸¤ä¾§æœç´¢
            const searchStep = 0.05;
            let bestT = initialT;
            let found = false;
            
            // å…ˆæ£€æŸ¥åˆå§‹ä½ç½®
            let testX = prevPos.x + dx * initialT;
            let testY = prevPos.y + dy * initialT;
            if (!checkWeightOverlap(testX, testY, boxWidth, boxHeight, angle)) {
                return { t: initialT, x: testX, y: testY, needsExpand: false };
            }
            
            // äº¤æ›¿å‘ä¸¤ä¾§æœç´¢
            for (let offset = searchStep; offset <= 0.5; offset += searchStep) {
                // å‘åæœç´¢
                let t1 = initialT - offset;
                if (t1 >= minT) {
                    testX = prevPos.x + dx * t1;
                    testY = prevPos.y + dy * t1;
                    if (!checkWeightOverlap(testX, testY, boxWidth, boxHeight, angle)) {
                        return { t: t1, x: testX, y: testY, needsExpand: false };
                    }
                }
                
                // å‘å‰æœç´¢
                let t2 = initialT + offset;
                if (t2 <= maxT) {
                    testX = prevPos.x + dx * t2;
                    testY = prevPos.y + dy * t2;
                    if (!checkWeightOverlap(testX, testY, boxWidth, boxHeight, angle)) {
                        return { t: t2, x: testX, y: testY, needsExpand: false };
                    }
                }
            }
            
            // å¦‚æœåœ¨è¿æ¥çº¿ä¸Šæ‰¾ä¸åˆ°ä½ç½®ï¼Œè¿”å›éœ€è¦æ‰©å±•çš„æ ‡è®°
            testX = prevPos.x + dx * initialT;
            testY = prevPos.y + dy * initialT;
            return { t: initialT, x: testX, y: testY, needsExpand: true };
        }

        // åŠ¨æ€è°ƒæ•´æƒé‡ä½ç½®ï¼ˆæ²¿è¿æ¥çº¿æ»‘åŠ¨ï¼Œé˜²é‡å ï¼‰
        function adjustWeightPosition(prevPos, currentPos, tRatio) {
            const dx = currentPos.x - prevPos.x;
            const dy = currentPos.y - prevPos.y;
            const angle = Math.atan2(dy, dx);
            
            const boxWidth = layoutParams.weightBoxWidth;
            const boxHeight = layoutParams.weightBoxHeight;
            
            // è®¡ç®—æ—‹è½¬åçš„æœ‰æ•ˆå°ºå¯¸
            const cos = Math.abs(Math.cos(angle));
            const sin = Math.abs(Math.sin(angle));
            const effectiveWidth = boxWidth * cos + boxHeight * sin;
            const effectiveHeight = boxWidth * sin + boxHeight * cos;
            
            const result = findNonOverlappingPosition(prevPos, currentPos, tRatio, boxWidth, boxHeight);
            
            // è®°å½•æœ€ç»ˆæƒé‡ä½ç½®
            weightPositions.push({ 
                x: result.x, 
                y: result.y, 
                width: effectiveWidth, 
                height: effectiveHeight 
            });
            
            return result;
        }

        // æƒé‡è¾“å…¥æ¡†åˆ›å»ºï¼ˆå‹åœ¨è¿çº¿ä¸Šã€é˜²é‡å ã€éšçº¿å€¾æ–œï¼Œå¸¦ä¸Šä¸‹æ ‡ï¼‰
        function createWeightInput(layerPairIndex, fromNode, toNode, prevPos, currentPos, tRatio, hasIntersection, targetLogicalLayer) {
            // åˆ›å»ºå®¹å™¨
            const container = document.createElement('div');
            container.className = 'weight-container';
            container.dataset.id = `${layerPairIndex},${fromNode},${toNode}`;
            
            // è®¡ç®—ä¸Šæ ‡å’Œä¸‹æ ‡
            // ä¸Šæ ‡ï¼šç›®æ ‡å±‚çš„é€»è¾‘å±‚ç¼–å·
            const superscript = targetLogicalLayer;
            // ä¸‹æ ‡ï¼šåä¸€ä¸ªç¥ç»å…ƒä½ç½® æ‹¼æ¥ å‰ä¸€ä¸ªç¥ç»å…ƒä½ç½®ï¼ˆä½ç½®ä»1å¼€å§‹ï¼‰
            const subscript = `${toNode + 1}${fromNode + 1}`;
            
            // åˆ›å»ºæ ‡ç­¾éƒ¨åˆ†ï¼šw + ä¸Šä¸‹æ ‡å †å  + =
            const label = document.createElement('span');
            label.className = 'weight-label';
            label.innerHTML = `<span class="weight-label-w">w</span><span class="weight-scripts"><span class="weight-superscript">${superscript}</span><span class="weight-subscript">${subscript}</span></span>=`;
            
            // åˆ›å»ºè¾“å…¥æ¡†
            const input = document.createElement('input');
            input.className = 'weight-input';
            const weightValue = neuralNetworkData.weights[layerPairIndex][fromNode][toNode] || 0;
            input.value = weightValue;

            // 1. è®¡ç®—è¿æ¥çº¿çš„æ–¹å‘å‘é‡ä¸é•¿åº¦
            const dx = currentPos.x - prevPos.x;
            const dy = currentPos.y - prevPos.y;
            const lineLength = Math.sqrt(dx * dx + dy * dy);

            // 2. è®¡ç®—è¿æ¥çº¿çš„å€¾æ–œè§’åº¦ï¼ˆå¼§åº¦åˆ¶ï¼‰
            const lineAngle = Math.atan2(dy, dx);

            // 3. è®¡ç®—æƒé‡ä½ç½®
            let adjustedPos;
            if (!hasIntersection) {
                // æ²¡æœ‰äº¤å‰çš„è¿æ¥ç›´æ¥ä½¿ç”¨ä¸­ç‚¹ï¼Œä¸åšé‡å è°ƒæ•´
                const midX = prevPos.x + dx * 0.5;
                const midY = prevPos.y + dy * 0.5;
                adjustedPos = { x: midX, y: midY };
            } else {
                // æœ‰äº¤å‰çš„è¿æ¥ä½¿ç”¨åŠ¨æ€è°ƒæ•´ä½ç½®é˜²é‡å 
                adjustedPos = adjustWeightPosition(prevPos, currentPos, tRatio || layoutParams.weightPositionRatio);
            }

            // 4. è®¾ç½®å®¹å™¨ä½ç½®ä¸å€¾æ–œè§’åº¦ï¼ˆå‹åœ¨è¿çº¿ä¸Šï¼‰
            const containerHeight = 22;
            
            // ç»„è£…å®¹å™¨å†…å®¹
            container.appendChild(label);
            container.appendChild(input);
            
            // å…ˆæ·»åŠ åˆ° DOM ä»¥è·å–å®é™…å®½åº¦
            visualizationContainer.appendChild(container);
            const containerWidth = container.offsetWidth;
            
            container.style.left = `${adjustedPos.x - containerWidth / 2}px`;
            container.style.top = `${adjustedPos.y - containerHeight / 2}px`;
            container.style.transform = `rotate(${lineAngle}rad)`;

            // 5. ç›‘å¬è¾“å…¥å˜åŒ–
            input.addEventListener('change', function() {
                let value = this.value.replace(/[^0-9.-]/g, '');
                value = parseFloat(value);
                value = isNaN(value) ? 0 : Number(value.toFixed(2));
                this.value = value;
                const [l, f, t] = container.dataset.id.split(',').map(Number);
                neuralNetworkData.weights[l][f][t] = value;
            });
            
            return container;
        }

        // åˆ›å»ºèŠ‚ç‚¹è‡ªå®šä¹‰å‚æ•°è¾“å…¥æ¡†ï¼ˆæ˜¾ç¤ºåœ¨ç¥ç»å…ƒå·¦ä¾§ï¼Œå¸¦æ ‡é¢˜ï¼Œä¸é®ç›–ç¥ç»å…ƒï¼‰
        function createNodeParamInputs(layerIndex, nodeIndex, x, y) {
            const layer = neuralNetworkData.layers[layerIndex];
            const node = layer.nodes[nodeIndex];
            if (!node || !node.customParams || node.customParams.length === 0) return;

            const paramCount = node.customParams.length;
            const totalParamHeight = paramCount * layoutParams.paramVerticalGap;
            
            // è®¡ç®—æ‰€æœ‰å‚æ•°ä¸­å˜é‡å+ä¸Šä¸‹æ ‡çš„æœ€å¤§å®½åº¦ï¼Œç”¨äºå¯¹é½ç­‰å·
            let maxBaseSubscriptWidth = 0;
            node.customParams.forEach(param => {
                let baseWidth = (param.base || 'y').length * 7;
                let supWidth = param.sup ? param.sup.length * 5 : 0;
                let subWidth = param.sub ? param.sub.length * 5 : 0;
                let maxSubscriptWidth = Math.max(supWidth, subWidth);
                let totalWidth = baseWidth + maxSubscriptWidth;
                maxBaseSubscriptWidth = Math.max(maxBaseSubscriptWidth, totalWidth);
            });
            
            // ç”Ÿæˆå®Œæ•´çš„å±‚åç§°
            let layerName = '';
            if (layer.type === 'input') {
                layerName = 'è¾“å…¥å±‚';
            } else if (layer.type === 'output') {
                layerName = 'è¾“å‡ºå±‚';
            } else if (layer.isZLayer) {
                layerName = `éšè—å±‚${layer.groupIndex}-z`;
            } else if (layer.isALayer) {
                layerName = `éšè—å±‚${layer.groupIndex}-a`;
            } else if (layer.isSingleLayer) {
                layerName = `éšè—å±‚${layer.singleLayerIndex}`;
            }
            
            // åˆ›å»ºå‚æ•°ç»„å®¹å™¨ï¼ˆåŒ…å«æ ‡é¢˜å’Œæ‰€æœ‰å‚æ•°ï¼‰
            const paramGroupContainer = document.createElement('div');
            paramGroupContainer.className = 'node-param-group';
            paramGroupContainer.dataset.nodeId = `${layerIndex},${nodeIndex}`;
            paramGroupContainer.style.position = 'absolute';
            
            const nodeId = `${layerIndex},${nodeIndex}`;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„è‡ªå®šä¹‰ä½ç½®
            if (panelPositions[nodeId]) {
                // ä½¿ç”¨ä¿å­˜çš„ä½ç½®
                paramGroupContainer.style.left = `${panelPositions[nodeId].x}px`;
                paramGroupContainer.style.top = `${panelPositions[nodeId].y}px`;
                paramGroupContainer.style.transform = 'none';
            } else {
                // é»˜è®¤ä½ç½®ï¼šå‚æ•°é¢æ¿æ˜¾ç¤ºåœ¨ç¥ç»å…ƒå·¦ä¾§ï¼Œç´§è´´ç¥ç»å…ƒ
                const rightEdge = x - layoutParams.nodeRadius - 5;
                paramGroupContainer.style.left = `${rightEdge}px`;
                paramGroupContainer.style.transform = 'translateX(-100%)';
                paramGroupContainer.style.top = `${y - totalParamHeight / 2 - 12}px`;
            }
            
            paramGroupContainer.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
            paramGroupContainer.style.border = '1px solid #d1d5db';
            paramGroupContainer.style.borderRadius = '4px';
            paramGroupContainer.style.padding = '3px 5px';
            paramGroupContainer.style.zIndex = '100';
            paramGroupContainer.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
            
            // æ£€æŸ¥æ˜¯å¦å·²å›ºå®š
            if (pinnedNodes.has(nodeId)) {
                paramGroupContainer.classList.add('pinned');
            }
            
            // é¼ æ ‡è¿›å…¥å‚æ•°é¢æ¿æ—¶ä¿æŒæ˜¾ç¤ºï¼Œå¹¶å–æ¶ˆéšè—å®šæ—¶å™¨
            paramGroupContainer.addEventListener('mouseenter', function() {
                if (hideTimeout) {
                    clearTimeout(hideTimeout);
                    hideTimeout = null;
                }
                this.classList.add('hover-active');
                this.classList.add('visible');
            });
            
            // é¼ æ ‡ç¦»å¼€å‚æ•°é¢æ¿æ—¶éšè—ï¼ˆé™¤éå·²å›ºå®šï¼‰
            paramGroupContainer.addEventListener('mouseleave', function() {
                this.classList.remove('hover-active');
                if (!this.classList.contains('pinned')) {
                    this.classList.remove('visible');
                }
            });
            
            // æ·»åŠ æ ‡é¢˜å®¹å™¨ï¼ˆåŒ…å«æ ‡é¢˜æ–‡æœ¬å’Œå›¾æ ‡ï¼‰- å¯æ‹–åŠ¨
            const titleContainer = document.createElement('div');
            titleContainer.className = 'param-title-container';
            
            // æ ‡é¢˜æ–‡æœ¬
            const titleText = document.createElement('span');
            titleText.className = 'param-title-text';
            titleText.textContent = `${layerName} - èŠ‚ç‚¹${nodeIndex + 1}å‚æ•°`;
            titleContainer.appendChild(titleText);
            
            // å›¾æ ‡å®¹å™¨
            const iconsContainer = document.createElement('span');
            iconsContainer.className = 'title-icons';
            
            // å›ºå®šå›¾æ ‡
            const pinIcon = document.createElement('span');
            pinIcon.className = 'pin-icon' + (pinnedNodes.has(nodeId) ? ' pinned' : '');
            pinIcon.textContent = pinnedNodes.has(nodeId) ? 'ğŸ“' : 'ğŸ“Œ';
            pinIcon.title = 'ç‚¹å‡»å›ºå®š/å–æ¶ˆå›ºå®šæ˜¾ç¤º';
            pinIcon.addEventListener('click', function(e) {
                e.stopPropagation();
                togglePinNode(layerIndex, nodeIndex);
            });
            iconsContainer.appendChild(pinIcon);
            
            // æŠ˜å å›¾æ ‡
            const collapseIcon = document.createElement('span');
            collapseIcon.className = 'collapse-icon' + (collapsedNodes.has(nodeId) ? ' collapsed' : '');
            collapseIcon.textContent = 'â–¼';
            collapseIcon.title = 'ç‚¹å‡»æŠ˜å /å±•å¼€å‚æ•°';
            collapseIcon.addEventListener('click', function(e) {
                e.stopPropagation();
                toggleCollapseNode(layerIndex, nodeIndex, paramGroupContainer);
            });
            iconsContainer.appendChild(collapseIcon);
            
            titleContainer.appendChild(iconsContainer);
            
            // æ‹–åŠ¨åŠŸèƒ½ - åœ¨æ ‡é¢˜æ ä¸ŠæŒ‰ä¸‹é¼ æ ‡å¼€å§‹æ‹–åŠ¨
            titleContainer.addEventListener('mousedown', function(e) {
                // å¦‚æœç‚¹å‡»çš„æ˜¯å›ºå®šå›¾æ ‡æˆ–æŠ˜å å›¾æ ‡ï¼Œä¸å¯åŠ¨æ‹–åŠ¨
                if (e.target.classList.contains('pin-icon') || e.target.classList.contains('collapse-icon')) return;
                
                e.preventDefault();
                isDraggingPanel = true;
                dragPanel = paramGroupContainer;
                
                // è·å–é¢æ¿å½“å‰ä½ç½®
                const rect = paramGroupContainer.getBoundingClientRect();
                const containerRect = visualizationContainer.getBoundingClientRect();
                
                // å¦‚æœæœ‰transformï¼Œéœ€è¦å…ˆç§»é™¤å¹¶è®¾ç½®å®é™…ä½ç½®
                if (paramGroupContainer.style.transform === 'translateX(-100%)') {
                    paramGroupContainer.style.left = `${rect.left - containerRect.left}px`;
                    paramGroupContainer.style.transform = 'none';
                }
                
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
            });
            
            paramGroupContainer.appendChild(titleContainer);
            
            // åˆ›å»ºå‚æ•°å†…å®¹å®¹å™¨ï¼ˆç”¨äºæŠ˜å ï¼‰
            const paramContent = document.createElement('div');
            paramContent.className = 'param-content' + (collapsedNodes.has(nodeId) ? ' collapsed' : '');
            
            // æ·»åŠ å„ä¸ªå‚æ•°
            node.customParams.forEach((param, paramIndex) => {
                const paramContainer = document.createElement('div');
                paramContainer.className = 'node-param-container';
                paramContainer.dataset.id = `${layerIndex},${nodeIndex},${paramIndex}`;
                paramContainer.style.position = 'relative';
                paramContainer.style.display = 'flex';
                paramContainer.style.alignItems = 'baseline';
                paramContainer.style.gap = '0';
            paramContainer.style.margin = '1px 0';
                paramContainer.style.padding = '0';
                paramContainer.style.border = 'none';
                paramContainer.style.backgroundColor = 'transparent';

                // åŸºç¡€åå®¹å™¨ï¼ˆåŒ…å«å˜é‡åã€å¸½å­ã€ä¸Šä¸‹æ ‡ï¼‰- è®¾ç½®å›ºå®šå®½åº¦ç”¨äºå¯¹é½ç­‰å·
                const baseWrapper = document.createElement('div');
                baseWrapper.className = 'param-base-wrapper';
                baseWrapper.style.display = 'inline-flex';
                baseWrapper.style.alignItems = 'baseline';
                baseWrapper.style.justifyContent = 'flex-start';
                baseWrapper.style.position = 'relative';
                baseWrapper.style.margin = '0';
                baseWrapper.style.padding = '0.3em 0 0 0';
                baseWrapper.style.width = `${maxBaseSubscriptWidth}px`;
                baseWrapper.style.gap = '0';
                baseWrapper.style.minHeight = '1.2em';
                
                // é¡¶æ ‡ï¼ˆå¸½å­ï¼‰
                if (param.hat) {
                    const hatSpan = document.createElement('span');
                    hatSpan.className = 'param-hat';
                    hatSpan.textContent = '^';
                    baseWrapper.appendChild(hatSpan);
                }
                
                // åŸºç¡€å
                const baseSpan = document.createElement('span');
                baseSpan.className = 'param-base';
                baseSpan.textContent = param.base || 'y';
                baseWrapper.appendChild(baseSpan);
                
                // ä¸Šä¸‹æ ‡å®¹å™¨
                if (param.sup || param.sub) {
                    const subscriptWrapper = document.createElement('div');
                    subscriptWrapper.style.display = 'inline-block';
                    subscriptWrapper.style.position = 'relative';
                    const currentSupWidth = param.sup ? param.sup.length * 5 : 0;
                    const currentSubWidth = param.sub ? param.sub.length * 5 : 0;
                    const currentMaxWidth = Math.max(currentSupWidth, currentSubWidth, 5);
                    subscriptWrapper.style.width = `${currentMaxWidth}px`;
                    subscriptWrapper.style.height = '1.2em';
                    subscriptWrapper.style.verticalAlign = 'baseline';
                    subscriptWrapper.style.fontSize = '0';
                    
                    if (param.sup) {
                        const supSpan = document.createElement('span');
                        supSpan.className = 'param-sup';
                        supSpan.textContent = param.sup;
                        subscriptWrapper.appendChild(supSpan);
                    }
                    
                    if (param.sub) {
                        const subSpan = document.createElement('span');
                        subSpan.className = 'param-sub';
                        subSpan.textContent = param.sub;
                        subscriptWrapper.appendChild(subSpan);
                    }
                    
                    baseWrapper.appendChild(subscriptWrapper);
                }
                
                paramContainer.appendChild(baseWrapper);

                const equalSpan = document.createElement('span');
                equalSpan.className = 'node-param-equal';
                equalSpan.textContent = '=';
                equalSpan.style.margin = '0 2px';

                const valueInput = document.createElement('input');
                valueInput.className = 'node-param-value edit-param-value';
                valueInput.dataset.paramIndex = paramIndex;
                valueInput.value = param.value;
                valueInput.style.width = 'auto';
                valueInput.style.minWidth = '30px';
                valueInput.style.maxWidth = '80px';
                valueInput.style.margin = '0';
                valueInput.style.padding = '0 2px';
                valueInput.style.boxSizing = 'content-box';
                
                // è¾“å…¥æ¡†å®½åº¦è‡ªé€‚åº”ï¼šæ ¹æ®å†…å®¹åŠ¨æ€è°ƒæ•´
                function adjustInputWidth(input) {
                    const tempSpan = document.createElement('span');
                    tempSpan.style.visibility = 'hidden';
                    tempSpan.style.position = 'absolute';
                    tempSpan.style.whiteSpace = 'nowrap';
                    tempSpan.style.fontSize = '11px';
                    tempSpan.textContent = input.value || '0';
                    document.body.appendChild(tempSpan);
                    const textWidth = tempSpan.offsetWidth + 8; // åŠ ç‚¹padding
                    document.body.removeChild(tempSpan);
                    input.style.width = Math.max(30, Math.min(80, textWidth)) + 'px';
                }
                
                // åˆå§‹åŒ–æ—¶è°ƒæ•´å®½åº¦
                adjustInputWidth(valueInput);
                
                // è¾“å…¥æ—¶åŠ¨æ€è°ƒæ•´å®½åº¦å¹¶åŒæ­¥æ›´æ–°
                valueInput.addEventListener('input', function() {
                    adjustInputWidth(this);
                    const [l, n, p] = paramContainer.dataset.id.split(',').map(Number);
                    neuralNetworkData.layers[l].nodes[n].customParams[p].value = this.value;
                    // åŒæ­¥åˆ°è‡ªå®šä¹‰å‚æ•°å¼¹çª—å’Œå‚æ•°æ ‡ç­¾
                    syncParamValueToPopup(l, n, p, this.value);
                    syncParamValueToLabel(l, n, p, this.value);
                });
                
                valueInput.addEventListener('blur', function() {
                    let value = parseFloat(this.value);
                    value = isNaN(value) ? 0 : Number(value.toFixed(2));
                    this.value = value;
                    const [l, n, p] = paramContainer.dataset.id.split(',').map(Number);
                    neuralNetworkData.layers[l].nodes[n].customParams[p].value = value;
                    // åŒæ­¥æ ¼å¼åŒ–åçš„å€¼
                    syncParamValueToPopup(l, n, p, value);
                    syncParamValueToLabel(l, n, p, value);
                });

                paramContainer.appendChild(equalSpan);
                paramContainer.appendChild(valueInput);
                paramContent.appendChild(paramContainer);
            });
            
            paramGroupContainer.appendChild(paramContent);
            visualizationContainer.appendChild(paramGroupContainer);
        }
        
        // åˆ‡æ¢æŠ˜å çŠ¶æ€
        function toggleCollapseNode(layerIndex, nodeIndex, panel) {
            const nodeId = `${layerIndex},${nodeIndex}`;
            const collapseIcon = panel.querySelector('.collapse-icon');
            const paramContent = panel.querySelector('.param-content');
            
            if (collapsedNodes.has(nodeId)) {
                collapsedNodes.delete(nodeId);
                if (collapseIcon) collapseIcon.classList.remove('collapsed');
                if (paramContent) paramContent.classList.remove('collapsed');
            } else {
                collapsedNodes.add(nodeId);
                if (collapseIcon) collapseIcon.classList.add('collapsed');
                if (paramContent) paramContent.classList.add('collapsed');
            }
        }
        
        // åˆ‡æ¢å…¨å±€å‚æ•°æ˜¾ç¤ºæ¨¡å¼
        function toggleAllParams() {
            showAllParamsMode = !showAllParamsMode;
            const btn = document.getElementById('toggleAllParams');
            
            if (showAllParamsMode) {
                btn.textContent = 'éšè—æ‰€æœ‰å‚æ•°';
                btn.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                btn.classList.add('bg-gray-500', 'hover:bg-gray-600');
            } else {
                btn.textContent = 'æ˜¾ç¤ºæ‰€æœ‰å‚æ•°';
                btn.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                btn.classList.add('bg-orange-500', 'hover:bg-orange-600');
            }
            
            // é‡æ–°ç»˜åˆ¶ä»¥æ›´æ–°å‚æ•°æ ‡ç­¾
            drawNeuralNetwork();
        }
        
        // æƒé‡æ˜¾ç¤ºçŠ¶æ€
        let showAllWeightsMode = false;
        
        // åˆ‡æ¢å…¨å±€æƒé‡æ˜¾ç¤ºæ¨¡å¼
        function toggleAllWeights() {
            showAllWeightsMode = !showAllWeightsMode;
            const btn = document.getElementById('toggleAllWeights');
            const containers = visualizationContainer.querySelectorAll('.weight-container');
            
            if (showAllWeightsMode) {
                btn.textContent = 'éšè—æ‰€æœ‰æƒé‡';
                btn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                btn.classList.add('bg-gray-500', 'hover:bg-gray-600');
                // æ˜¾ç¤ºæ‰€æœ‰æƒé‡
                containers.forEach(container => {
                    container.classList.add('visible');
                });
            } else {
                btn.textContent = 'æ˜¾ç¤ºæ‰€æœ‰æƒé‡';
                btn.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                btn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
                // éšè—æ‰€æœ‰æƒé‡
                containers.forEach(container => {
                    container.classList.remove('visible');
                });
            }
        }
        
        // åˆ›å»ºèŠ‚ç‚¹å‚æ•°æ ‡ç­¾ï¼ˆæ˜¾ç¤ºåœ¨èŠ‚ç‚¹ä¸Šæ–¹æˆ–ä¸‹æ–¹ï¼‰
        function createNodeParamLabel(layerIndex, nodeIndex, x, y, canvasHeight) {
            const layer = neuralNetworkData.layers[layerIndex];
            const node = layer.nodes[nodeIndex];
            if (!node || !node.customParams || node.customParams.length === 0) return;
            
            const label = document.createElement('div');
            label.className = 'node-param-label';
            label.dataset.nodeId = `${layerIndex},${nodeIndex}`;
            
            // æ„å»ºå‚æ•°æ˜¾ç¤ºå†…å®¹
            node.customParams.forEach((param, idx) => {
                const paramItem = document.createElement('span');
                paramItem.className = 'param-item';
                paramItem.style.position = 'relative';
                
                // é¡¶æ ‡ï¼ˆå¸½å­ï¼‰
                if (param.hat) {
                    const hatSpan = document.createElement('span');
                    hatSpan.className = 'param-hat';
                    hatSpan.textContent = '^';
                    paramItem.appendChild(hatSpan);
                }
                
                // åŸºç¡€å
                const baseSpan = document.createElement('span');
                baseSpan.className = 'param-base';
                baseSpan.textContent = param.base || 'b';
                paramItem.appendChild(baseSpan);
                
                // ä¸Šä¸‹æ ‡ï¼ˆå‚è€ƒ w å‚æ•°çš„æ˜¾ç¤ºæ–¹å¼ï¼‰
                if (param.sup || param.sub) {
                    const scriptsSpan = document.createElement('span');
                    scriptsSpan.className = 'param-scripts';
                    
                    // å§‹ç»ˆåˆ›å»ºä¸Šæ ‡å…ƒç´ ï¼ˆå³ä½¿ä¸ºç©ºä¹Ÿå ä½ï¼‰
                    const supSpan = document.createElement('span');
                    supSpan.className = 'param-sup';
                    supSpan.textContent = param.sup || '';
                    scriptsSpan.appendChild(supSpan);
                    
                    // å§‹ç»ˆåˆ›å»ºä¸‹æ ‡å…ƒç´ ï¼ˆå³ä½¿ä¸ºç©ºä¹Ÿå ä½ï¼‰
                    const subSpan = document.createElement('span');
                    subSpan.className = 'param-sub';
                    subSpan.textContent = param.sub || '';
                    scriptsSpan.appendChild(subSpan);
                    
                    paramItem.appendChild(scriptsSpan);
                }
                
                // ç­‰å·
                const equalSpan = document.createElement('span');
                equalSpan.textContent = '=';
                paramItem.appendChild(equalSpan);
                
                // å€¼ï¼ˆå¯ç¼–è¾‘è¾“å…¥æ¡†ï¼‰
                const valueInput = document.createElement('input');
                valueInput.className = 'param-value-input';
                valueInput.type = 'text';
                valueInput.value = param.value;
                valueInput.dataset.layerIndex = layerIndex;
                valueInput.dataset.nodeIndex = nodeIndex;
                valueInput.dataset.paramIndex = idx;
                
                // ç›‘å¬å€¼å˜åŒ–ï¼ˆä½¿ç”¨ input äº‹ä»¶å®ç°å®æ—¶æ›´æ–°ï¼‰
                valueInput.addEventListener('input', function() {
                    const li = parseInt(this.dataset.layerIndex);
                    const ni = parseInt(this.dataset.nodeIndex);
                    const pi = parseInt(this.dataset.paramIndex);
                    if (neuralNetworkData.layers[li] && 
                        neuralNetworkData.layers[li].nodes[ni] && 
                        neuralNetworkData.layers[li].nodes[ni].customParams[pi]) {
                        neuralNetworkData.layers[li].nodes[ni].customParams[pi].value = this.value;
                        // åŒæ­¥æ›´æ–°å¼¹çª—ä¸­çš„è¾“å…¥æ¡†
                        syncParamValueToPopup(li, ni, pi, this.value);
                    }
                });
                
                // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…è§¦å‘ç”»å¸ƒæ‹–åŠ¨
                valueInput.addEventListener('mousedown', function(e) {
                    e.stopPropagation();
                });
                
                paramItem.appendChild(valueInput);
                
                label.appendChild(paramItem);
                
                // æ·»åŠ åˆ†éš”ç¬¦ï¼ˆé™¤äº†æœ€åä¸€ä¸ªï¼‰
                if (idx < node.customParams.length - 1) {
                    const separator = document.createElement('span');
                    separator.textContent = ',';
                    separator.style.marginRight = '1px';
                    label.appendChild(separator);
                }
            });
            
            // å…ˆæ·»åŠ åˆ°DOMä»¥è·å–å®é™…å°ºå¯¸
            visualizationContainer.appendChild(label);
            const labelRect = label.getBoundingClientRect();
            const labelHeight = labelRect.height;
            const labelWidth = labelRect.width;
            
            // åˆ¤æ–­æ˜¾ç¤ºåœ¨ä¸Šæ–¹è¿˜æ˜¯ä¸‹æ–¹
            const nodeRadius = layoutParams.nodeRadius;
            const margin = 1; // ä¸èŠ‚ç‚¹çš„é—´è·ï¼ˆè´´è¿‘èŠ‚ç‚¹ï¼‰
            const topSpace = y - nodeRadius - margin - labelHeight;
            const bottomSpace = canvasHeight - (y + nodeRadius + margin + labelHeight);
            
            // ä¼˜å…ˆæ˜¾ç¤ºåœ¨ä¸Šæ–¹ï¼Œå¦‚æœä¸Šæ–¹ç©ºé—´ä¸è¶³åˆ™æ˜¾ç¤ºåœ¨ä¸‹æ–¹
            let labelY;
            if (topSpace >= 20) {
                // æ˜¾ç¤ºåœ¨ä¸Šæ–¹
                labelY = y - nodeRadius - margin - labelHeight;
            } else {
                // æ˜¾ç¤ºåœ¨ä¸‹æ–¹
                labelY = y + nodeRadius + margin;
            }
            
            label.style.left = `${x - labelWidth / 2}px`;
            label.style.top = `${labelY}px`;
        }
        
        // æ¸…é™¤æ‰€æœ‰å‚æ•°æ ‡ç­¾
        function clearParamLabels() {
            const labels = visualizationContainer.querySelectorAll('.node-param-label');
            labels.forEach(label => label.remove());
        }
        
        // æ›´æ–°æ‰€æœ‰å‚æ•°æ ‡ç­¾ï¼ˆä¸é‡ç»˜æ•´ä¸ªç½‘ç»œï¼‰
        function updateParamLabels() {
            if (!showAllParamsMode) return;
            
            // æ¸…é™¤ç°æœ‰æ ‡ç­¾
            clearParamLabels();
            
            // é‡æ–°åˆ›å»ºæ‰€æœ‰å‚æ•°æ ‡ç­¾
            neuralNetworkData.layers.forEach((layer, layerIndex) => {
                layer.nodes.forEach((node, nodeIndex) => {
                    if (node.x && node.y && node.customParams && node.customParams.length > 0) {
                        createNodeParamLabel(layerIndex, nodeIndex, node.x, node.y, canvas.height);
                    }
                });
            });
        }

        // ç»˜åˆ¶ç¥ç»ç½‘ç»œï¼ˆæ•´åˆæ‰€æœ‰ä¼˜åŒ–åŠŸèƒ½ï¼šåŠ¨æ€å‚ç›´é—´è·ã€é˜²é‡å ã€è‡ªé€‚åº”ç´§å‡‘å¸ƒå±€ï¼‰
        function drawNeuralNetwork(isRetry = false) {
            const layers = neuralNetworkData.layers;
            const layerCount = layers.length;
            if (layerCount < 2) return;
            
            // é¦–æ¬¡ç»˜åˆ¶æ—¶é‡ç½®åŠ¨æ€å€æ•°
            if (!isRetry) {
                layoutParams.dynamicLayerWidthMultiplier = 1.0;
                layoutParams.dynamicVerticalMultiplier = 1.0;
            }

            // è®¡ç®—æœ€å¤§èŠ‚ç‚¹æ•°ï¼Œç”¨äºåŠ¨æ€è°ƒæ•´é—´è·
            const maxNodeCount = Math.max(...layers.map(l => l.nodeCount));
            
            // æ ¹æ®å±‚æ•°å’ŒèŠ‚ç‚¹æ•°åŠ¨æ€è°ƒæ•´åŸºç¡€é—´è·ï¼Œä½¿å¸ƒå±€æ›´ç´§å‡‘
            // å±‚æ•°è¶Šå¤šï¼Œå±‚é—´è·è¶Šå°ï¼›èŠ‚ç‚¹æ•°è¶Šå¤šï¼Œå‚ç›´é—´è·è¶Šå°
            const layerWidthFactor = Math.max(0.5, 1 - (layerCount - 2) * 0.08);
            const verticalFactor = Math.max(0.6, 1 - (maxNodeCount - 3) * 0.05);
            
            const effectiveLayerWidth = Math.max(
                layoutParams.minLayerWidth,
                layoutParams.baseLayerWidth * layerWidthFactor * layoutParams.dynamicLayerWidthMultiplier
            );
            const effectiveVerticalSpacing = Math.max(
                layoutParams.minVerticalSpacing,
                layoutParams.verticalSpacingBase * verticalFactor * layoutParams.dynamicVerticalMultiplier
            );
            
            // ä¸€å¯¹ä¸€è¿æ¥ï¼ˆzâ†’aå±‚ï¼‰ä½¿ç”¨æ›´å°çš„é—´è·
            const oneToOneLayerWidth = Math.max(60, effectiveLayerWidth * 0.4);
            
            // è®¡ç®—æ¯ä¸ªå±‚é—´éš”çš„å®½åº¦ï¼ˆåŒºåˆ†ä¸€å¯¹ä¸€å’Œå…¨è¿æ¥ï¼‰
            const layerGaps = [];
            for (let i = 0; i < layerCount - 1; i++) {
                const isOneToOne = layers[i].isZLayer && layers[i + 1].isALayer;
                layerGaps.push(isOneToOne ? oneToOneLayerWidth : effectiveLayerWidth);
            }
            
            // è®¡ç®—æ€»å®½åº¦
            const totalGapWidth = layerGaps.reduce((sum, gap) => sum + gap, 0);

            // 1. åŠ¨æ€è®¡ç®—ç”»å¸ƒå®½åº¦ï¼ˆåŸºäºå±‚æ•°å’ŒåŸºç¡€å®½åº¦ï¼Œç´§å‡‘å¸ƒå±€ï¼‰
            const requiredWidth = totalGapWidth + 2 * layoutParams.canvasPadding;
            canvas.width = Math.max(600, requiredWidth);

            // 2. é¢„è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„å‚ç›´é«˜åº¦éœ€æ±‚å’Œæ¯å±‚çš„æ€»é«˜åº¦
            let maxLayerHeight = 0;
            const layerLayouts = []; // å­˜å‚¨æ¯å±‚çš„èŠ‚ç‚¹å¸ƒå±€ä¿¡æ¯ { totalHeight: number, nodeHeights: number[] }

            layers.forEach((layer, layerIndex) => {
                let currentY = 0;
                const nodeHeights = []; // è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„å ç”¨é«˜åº¦ï¼ˆå«å‚æ•° + åŠ¨æ€é—´è·ï¼‰
                
                // è®¡ç®—å½“å‰å±‚èŠ‚ç‚¹çš„è¿æ¥å¯†åº¦ï¼ˆå–å‰åå±‚æœ€å¤§è¿æ¥æ•°ï¼‰
                let densityPadding = 0;
                
                // è·å–å‰ä¸€å±‚èŠ‚ç‚¹æ•° (fan-in)
                let fanIn = 0;
                if (layerIndex > 0) {
                    const prevLayer = layers[layerIndex - 1];
                    // å¦‚æœæ˜¯ Z->A å±‚ï¼Œåˆ™æ˜¯ 1:1 è¿æ¥ï¼Œå¦åˆ™æ˜¯å…¨è¿æ¥
                    fanIn = (prevLayer.isZLayer && layer.isALayer) ? 1 : prevLayer.nodeCount;
                }
                
                // è·å–åä¸€å±‚èŠ‚ç‚¹æ•° (fan-out)
                let fanOut = 0;
                if (layerIndex < layers.length - 1) {
                    const nextLayer = layers[layerIndex + 1];
                    // å¦‚æœæ˜¯ Z->A å±‚ï¼Œåˆ™æ˜¯ 1:1 è¿æ¥ï¼Œå¦åˆ™æ˜¯å…¨è¿æ¥
                    fanOut = (layer.isZLayer && nextLayer.isALayer) ? 1 : nextLayer.nodeCount;
                }
                
                // å–æœ€å¤§è¿æ¥æ•°ä½œä¸ºå¯†åº¦å‚è€ƒï¼Œä½†é™åˆ¶å¢é‡é¿å…è¿‡åº¦æ‰©å±•
                const maxConnectivity = Math.max(fanIn, fanOut);
                
                // è¿æ¥æ•°è¶…è¿‡é˜ˆå€¼æ—¶å¢åŠ é—´è·ï¼Œä½†é™åˆ¶æœ€å¤§å¢é‡
                if (maxConnectivity > 2) {
                    densityPadding = Math.min(30, (maxConnectivity - 2) * 8);
                }

                // ä½¿ç”¨ nodeCount è€Œä¸æ˜¯ layer.nodes.lengthï¼Œç¡®ä¿ä¸å®é™…èŠ‚ç‚¹æ•°ä¸€è‡´
                for (let nodeIndex = 0; nodeIndex < layer.nodeCount; nodeIndex++) {
                    // èŠ‚ç‚¹è‡ªèº«å ç”¨é«˜åº¦ï¼ˆç›´å¾„ + åŸºç¡€é—´è· + å¯†åº¦åŠ¨æ€é—´è·ï¼‰
                    const nodeTotalHeight = effectiveVerticalSpacing + densityPadding;
                    nodeHeights.push(nodeTotalHeight);
                    currentY += nodeTotalHeight;
                }

                // å±‚æ€»é«˜åº¦ = æ‰€æœ‰èŠ‚ç‚¹é«˜åº¦ä¹‹å’Œ
                const totalHeight = Math.max(currentY, (layer.nodeCount - 1) * effectiveVerticalSpacing + 80);
                
                if (totalHeight > maxLayerHeight) {
                    maxLayerHeight = totalHeight;
                }

                layerLayouts.push({
                    totalHeight: totalHeight,
                    nodeHeights: nodeHeights
                });
            });

            // 3. ç¡®ä¿ç”»å¸ƒé«˜åº¦è¶³å¤Ÿä½†ä¸è¿‡å¤§
            canvas.height = Math.max(400, maxLayerHeight + 100);

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            clearEditableInputs();
            clearParamLabels();
            
            // è®¡ç®—æ¯å±‚çš„Xåæ ‡ï¼ˆåŸºäºç´¯è®¡çš„å±‚é—´è·ï¼Œå¹¶å±…ä¸­æ˜¾ç¤ºï¼‰
            const totalNetworkWidth = totalGapWidth; // ç½‘ç»œæ€»å®½åº¦ï¼ˆä¸å«è¾¹è·ï¼‰
            const startX = (canvas.width - totalNetworkWidth) / 2; // å±…ä¸­èµ·å§‹ä½ç½®
            const layerXPositions = [startX];
            for (let i = 0; i < layerCount - 1; i++) {
                layerXPositions.push(layerXPositions[i] + layerGaps[i]);
            }
            
            const layerNodePositions = [];
            
            // è®¡ç®—æ¯ä¸ªç‰©ç†å±‚å¯¹åº”çš„é€»è¾‘å±‚ç¼–å·ï¼ˆç”¨äºèŠ‚ç‚¹æ ‡ç­¾ï¼‰
            // è§„åˆ™ï¼šè¾“å…¥å±‚=0ï¼Œæ¯ä¸ªéšè—å±‚ï¼ˆå•å±‚æˆ–z-aç»„ï¼‰ç®—ä¸€ä¸ªé€»è¾‘å±‚ï¼Œz-aç»„ä¸­aå±‚ä¸zå±‚å…±äº«ç¼–å·
            const logicalLayerIndicesForLabels = [];
            let logicalIdx = 0;
            for (let i = 0; i < layerCount; i++) {
                const layer = layers[i];
                if (layer.type === 'input') {
                    logicalLayerIndicesForLabels.push(0);
                    logicalIdx = 1;
                } else if (layer.type === 'output') {
                    logicalLayerIndicesForLabels.push(logicalIdx);
                } else if (layer.isALayer) {
                    // aå±‚ä¸å‰é¢çš„zå±‚å…±äº«é€»è¾‘å±‚ç¼–å·
                    logicalLayerIndicesForLabels.push(logicalLayerIndicesForLabels[i - 1]);
                } else {
                    // zå±‚æˆ–å•å±‚éšè—å±‚
                    logicalLayerIndicesForLabels.push(logicalIdx);
                    logicalIdx++;
                }
            }
            
            // 4. ç»˜åˆ¶å„å±‚èŠ‚ç‚¹
            layers.forEach((layer, layerIndex) => {
                const layerX = layerXPositions[layerIndex];
                const nodeCount = layer.nodeCount;
                const layout = layerLayouts[layerIndex];
                
                // è®¡ç®—èµ·å§‹Yåæ ‡ï¼Œä½¿è¯¥å±‚åœ¨ç”»å¸ƒå‚ç›´å±…ä¸­
                let currentY = (canvas.height - layout.totalHeight) / 2;
                
                const layerNodeY = [];
                
                // æ£€æŸ¥å½“å‰å±‚æ˜¯å¦æ˜¯ a å±‚ï¼Œå¦‚æœæ˜¯åˆ™å¤ç”¨å¯¹åº” z å±‚çš„ Y åæ ‡
                let useZLayerYPositions = false;
                let zLayerYPositions = null;
                if (layer.isALayer && layerIndex > 0) {
                    const prevLayer = layers[layerIndex - 1];
                    if (prevLayer.isZLayer && prevLayer.groupIndex === layer.groupIndex) {
                        // æ‰¾åˆ°å¯¹åº”çš„ z å±‚ï¼Œå¤ç”¨å…¶ Y åæ ‡
                        useZLayerYPositions = true;
                        zLayerYPositions = layerNodePositions[layerIndex - 1].yList;
                    }
                }

                for (let nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++) {
                    let nodeY;
                    
                    if (useZLayerYPositions && zLayerYPositions && nodeIndex < zLayerYPositions.length) {
                        // a å±‚ä½¿ç”¨å¯¹åº” z å±‚èŠ‚ç‚¹çš„ Y åæ ‡ï¼Œä¿æŒæ°´å¹³å¯¹é½
                        nodeY = zLayerYPositions[nodeIndex];
                    } else {
                        const nodeHeight = layout.nodeHeights[nodeIndex];
                        // èŠ‚ç‚¹ä½äºå…¶åˆ†é…ç©ºé—´çš„ä¸­å¿ƒä½ç½®
                        nodeY = currentY + nodeHeight / 2;
                        currentY += nodeHeight;
                    }
                    
                    layerNodeY.push(nodeY);
                    
                    // å­˜å‚¨èŠ‚ç‚¹åæ ‡ä¾›ç‚¹å‡»æ£€æµ‹ä½¿ç”¨
                    layer.nodes[nodeIndex].x = layerX;
                    layer.nodes[nodeIndex].y = nodeY;

                    // ç»˜åˆ¶èŠ‚ç‚¹ï¼ˆzå±‚è™šçº¿ï¼Œaå±‚/è¾“å…¥å±‚/è¾“å‡ºå±‚å®çº¿ï¼‰
                    ctx.beginPath();
                    ctx.arc(layerX, nodeY, layoutParams.nodeRadius, 0, Math.PI * 2);
                    if (layer.isZLayer) {
                        ctx.fillStyle = 'rgba(245, 158, 11, 0.2)';
                        ctx.strokeStyle = '#f59e0b';
                        ctx.setLineDash([5, 3]);
                    } else {
                        ctx.fillStyle = layer.type === 'input' ? '#3b82f6' : layer.type === 'hidden' ? '#f59e0b' : '#10b981';
                        ctx.strokeStyle = '#1e293b';
                        ctx.setLineDash([]);
                    }
                    ctx.fill();
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // ç»˜åˆ¶èŠ‚ç‚¹æ ‡ç­¾ï¼ˆå¸¦ä¸Šä¸‹æ ‡ï¼‰
                    ctx.fillStyle = layer.isZLayer ? '#1e293b' : '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // æ ¹æ®å±‚ç±»å‹ç”ŸæˆèŠ‚ç‚¹æ ‡ç­¾
                    const logicalLayer = logicalLayerIndicesForLabels[layerIndex];
                    
                    if (layer.type === 'input') {
                        // è¾“å…¥å±‚ï¼šx + ä¸‹æ ‡ï¼ˆèŠ‚ç‚¹ä½ç½®ï¼‰
                        ctx.font = '12px Arial';
                        ctx.fillText('x', layerX - 4, nodeY);
                        ctx.font = '8px Arial';
                        ctx.fillText(nodeIndex + 1, layerX + 5, nodeY + 4);
                    } else if (layer.type === 'output') {
                        // è¾“å‡ºå±‚ï¼šÅ· + ä¸‹æ ‡ï¼ˆèŠ‚ç‚¹ä½ç½®ï¼‰
                        ctx.font = '12px Arial';
                        ctx.fillText('Å·', layerX - 3, nodeY);
                        ctx.font = '8px Arial';
                        ctx.fillText(nodeIndex + 1, layerX + 6, nodeY + 4);
                    } else if (layer.isZLayer) {
                        // zå±‚ï¼šz + ä¸Šæ ‡ï¼ˆé€»è¾‘å±‚ï¼‰+ ä¸‹æ ‡ï¼ˆèŠ‚ç‚¹ä½ç½®ï¼‰
                        ctx.font = '12px Arial';
                        ctx.fillText('z', layerX - 4, nodeY);
                        ctx.font = '7px Arial';
                        ctx.fillText(logicalLayer, layerX + 3, nodeY - 5);
                        ctx.fillText(nodeIndex + 1, layerX + 3, nodeY + 5);
                    } else if (layer.isALayer) {
                        // aå±‚ï¼ša + ä¸Šæ ‡ï¼ˆé€»è¾‘å±‚ï¼‰+ ä¸‹æ ‡ï¼ˆèŠ‚ç‚¹ä½ç½®ï¼‰
                        ctx.font = '12px Arial';
                        ctx.fillText('a', layerX - 4, nodeY);
                        ctx.font = '7px Arial';
                        ctx.fillText(logicalLayer, layerX + 3, nodeY - 5);
                        ctx.fillText(nodeIndex + 1, layerX + 3, nodeY + 5);
                    } else if (layer.isSingleLayer) {
                        // å•å±‚éšè—å±‚ï¼ša + ä¸Šæ ‡ï¼ˆé€»è¾‘å±‚ï¼‰+ ä¸‹æ ‡ï¼ˆèŠ‚ç‚¹ä½ç½®ï¼‰
                        ctx.font = '12px Arial';
                        ctx.fillText('a', layerX - 4, nodeY);
                        ctx.font = '7px Arial';
                        ctx.fillText(logicalLayer, layerX + 3, nodeY - 5);
                        ctx.fillText(nodeIndex + 1, layerX + 3, nodeY + 5);
                    }
                    
                    // ç»˜åˆ¶èŠ‚ç‚¹è‡ªå®šä¹‰å‚æ•°
                    createNodeParamInputs(layerIndex, nodeIndex, layerX, nodeY);
                    
                    // å¦‚æœå¼€å¯äº†å…¨å±€å‚æ•°æ˜¾ç¤ºæ¨¡å¼ï¼Œåˆ›å»ºå‚æ•°æ ‡ç­¾
                    if (showAllParamsMode) {
                        createNodeParamLabel(layerIndex, nodeIndex, layerX, nodeY, canvas.height);
                    }
                }
                
                layerNodePositions.push({
                    x: layerX,
                    yList: layerNodeY,
                    nodeCount: nodeCount
                });
                
                // ç»˜åˆ¶å±‚åç§°ï¼ˆæŒ‰ç»„ç¼–å·ï¼‰
                ctx.fillStyle = '#1e293b';
                ctx.font = '16px Arial bold';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                let layerName = '';
                if (layer.type === 'input') {
                    layerName = 'è¾“å…¥å±‚';
                } else if (layer.type === 'output') {
                    layerName = 'è¾“å‡ºå±‚';
                } else if (layer.isZLayer) {
                    layerName = `éšè—å±‚ ${layer.groupIndex}-z`;
                } else if (layer.isALayer) {
                    layerName = `éšè—å±‚ ${layer.groupIndex}-a`;
                } else if (layer.isSingleLayer) {
                    layerName = `éšè—å±‚ ${layer.singleLayerIndex}`;
                }
                ctx.fillText(layerName, layerX, layoutParams.canvasPadding / 2);
            });
            
            // ç»˜åˆ¶è¿çº¿
            const weightInputs = []; // æ”¶é›†æ‰€æœ‰æƒé‡è¾“å…¥æ¡†ä»¥ä¾¿åç»­åšç¢°æ’æ£€æµ‹
            
            // æ¸…ç©ºè¿æ¥çº¿ä¿¡æ¯ï¼ˆç”¨äºæ‚¬æµ®æ£€æµ‹ï¼‰
            connectionLines = [];

            // å…ˆè®¡ç®—æ¯ä¸ªç‰©ç†å±‚å¯¹åº”çš„é€»è¾‘å±‚ç¼–å·
            // è§„åˆ™ï¼šè¾“å…¥å±‚=0ï¼Œæ¯ä¸ªéšè—å±‚ï¼ˆå•å±‚æˆ–z-aç»„ï¼‰ç®—ä¸€ä¸ªé€»è¾‘å±‚ï¼Œz-aç»„ä¸­aå±‚ä¸zå±‚å…±äº«ç¼–å·
            const logicalLayerIndices = [];
            let logicalIndex = 0;
            for (let i = 0; i < layerCount; i++) {
                const layer = layers[i];
                if (layer.type === 'input') {
                    logicalLayerIndices.push(0);
                    logicalIndex = 1;
                } else if (layer.type === 'output') {
                    logicalLayerIndices.push(logicalIndex);
                } else if (layer.isALayer) {
                    // aå±‚ä¸å‰é¢çš„zå±‚å…±äº«é€»è¾‘å±‚ç¼–å·
                    logicalLayerIndices.push(logicalLayerIndices[i - 1]);
                } else {
                    // zå±‚æˆ–å•å±‚éšè—å±‚
                    logicalLayerIndices.push(logicalIndex);
                    logicalIndex++;
                }
            }

            // å…ˆç»˜åˆ¶æ‰€æœ‰è¿çº¿å¹¶æ”¶é›†æƒé‡
            // 1. æ”¶é›†æ‰€æœ‰è¿æ¥ä¿¡æ¯
            const connections = [];

            for (let i = 0; i < layerCount - 1; i++) {
                const currentLayerNodes = layerNodePositions[i];
                const nextLayerNodes = layerNodePositions[i+1];
                const layerPairIndex = i;
                
                const isZALayerPair = layers[i].isZLayer && layers[i+1].isALayer;
                
                // è·å–ç›®æ ‡å±‚çš„é€»è¾‘å±‚ç¼–å·ï¼ˆç”¨äºæƒé‡ä¸Šæ ‡ï¼‰
                const targetLogicalLayer = logicalLayerIndices[i + 1];
                
                currentLayerNodes.yList.forEach((prevNodeY, prevNodeIndex) => {
                    const toNodeRange = isZALayerPair 
                        ? (prevNodeIndex < nextLayerNodes.nodeCount ? [prevNodeIndex] : []) 
                        : Array.from({length: nextLayerNodes.nodeCount}, (_, k) => k);

                    toNodeRange.forEach(currentNodeIndex => {
                        const prevPos = { x: currentLayerNodes.x + layoutParams.nodeRadius, y: prevNodeY };
                        const currentPos = { x: nextLayerNodes.x - layoutParams.nodeRadius, y: nextLayerNodes.yList[currentNodeIndex] };
                        
                        // è®¡ç®—è‡ªç„¶ä¸­ç‚¹
                        const midX = (prevPos.x + currentPos.x) / 2;
                        const midY = (prevPos.y + currentPos.y) / 2;
                        
                        connections.push({
                            layerPairIndex,
                            fromNode: prevNodeIndex,
                            toNode: currentNodeIndex,
                            prevPos,
                            currentPos,
                            midX,
                            midY,
                            tRatio: 0.5, // é»˜è®¤ 0.5ï¼ˆä¸­ç‚¹ï¼‰
                            isOneToOne: isZALayerPair, // æ ‡è®°æ˜¯å¦ä¸ºä¸€å¯¹ä¸€è¿æ¥
                            targetLogicalLayer // ç›®æ ‡å±‚çš„é€»è¾‘å±‚ç¼–å·
                        });
                        
                        // ä¿å­˜è¿æ¥çº¿ä¿¡æ¯ç”¨äºæ‚¬æµ®æ£€æµ‹
                        connectionLines.push({
                            layerPairIndex,
                            fromNode: prevNodeIndex,
                            toNode: currentNodeIndex,
                            prevPos,
                            currentPos
                        });
                    });
                });
            }

            // 2. é¢„åˆ†é… tRatioï¼Œå°½é‡åˆ†æ•£æƒé‡ä½ç½®
            // æŒ‰å±‚å¯¹åˆ†ç»„ï¼Œæ£€æµ‹æ¯æ¡è¿æ¥çº¿æ˜¯å¦ä¸å…¶ä»–è¿æ¥çº¿æœ‰äº¤å‰
            // æ²¡æœ‰äº¤å‰çš„è¿æ¥ä¿æŒ tRatio = 0.5ï¼ˆä¸­ç‚¹ï¼‰
            const layerPairGroups = {};
            connections.forEach(conn => {
                const key = conn.layerPairIndex;
                if (!layerPairGroups[key]) layerPairGroups[key] = [];
                layerPairGroups[key].push(conn);
            });
            
            // æ£€æµ‹ä¸¤æ¡è¿æ¥çº¿æ˜¯å¦äº¤å‰
            function doLinesIntersect(conn1, conn2) {
                // å¦‚æœä¸¤æ¡çº¿çš„èµ·ç‚¹æˆ–ç»ˆç‚¹ç›¸åŒï¼Œä¸ç®—äº¤å‰
                if (conn1.fromNode === conn2.fromNode || conn1.toNode === conn2.toNode) {
                    return false;
                }
                // æ£€æµ‹äº¤å‰ï¼šå¦‚æœèµ·ç‚¹é¡ºåºå’Œç»ˆç‚¹é¡ºåºä¸åŒï¼Œåˆ™äº¤å‰
                const startOrder = conn1.prevPos.y < conn2.prevPos.y;
                const endOrder = conn1.currentPos.y < conn2.currentPos.y;
                return startOrder !== endOrder;
            }
            
            // å¯¹æ¯ä¸ªå±‚å¯¹å†…çš„è¿æ¥è¿›è¡Œæ™ºèƒ½åˆ†é…
            Object.values(layerPairGroups).forEach(group => {
                const count = group.length;
                if (count <= 1) {
                    // åªæœ‰ä¸€æ¡è¿æ¥ï¼Œå›ºå®šåœ¨ä¸­ç‚¹
                    if (count === 1) {
                        group[0].tRatio = 0.5;
                        group[0].hasIntersection = false;
                    }
                    return;
                }
                
                // ä¸ºæ¯æ¡è¿æ¥æ£€æµ‹æ˜¯å¦ä¸å…¶ä»–è¿æ¥æœ‰äº¤å‰
                group.forEach(conn => {
                    conn.hasIntersection = false;
                    for (let i = 0; i < group.length; i++) {
                        if (group[i] !== conn && doLinesIntersect(conn, group[i])) {
                            conn.hasIntersection = true;
                            break;
                        }
                    }
                });
                
                // ç­›é€‰å‡ºæœ‰äº¤å‰çš„è¿æ¥ï¼Œéœ€è¦åˆ†æ•£ä½ç½®
                const intersectingConns = group.filter(conn => conn.hasIntersection);
                
                // æ²¡æœ‰äº¤å‰çš„è¿æ¥ä¿æŒä¸­ç‚¹
                group.forEach(conn => {
                    if (!conn.hasIntersection) {
                        conn.tRatio = 0.5;
                    }
                });
                
                // æœ‰äº¤å‰çš„è¿æ¥æŒ‰ Y åæ ‡æ’åºå¹¶åˆ†æ•£
                if (intersectingConns.length > 1) {
                    intersectingConns.sort((a, b) => a.midY - b.midY);
                    const maxSpread = Math.min(0.6, 0.1 * intersectingConns.length);
                    const step = maxSpread / (intersectingConns.length - 1 || 1);
                    const startT = 0.5 - maxSpread / 2;
                    
                    intersectingConns.forEach((conn, index) => {
                        conn.tRatio = startT + index * step;
                    });
                }
            });
            
            // 3. æ£€æµ‹é‡å å¹¶åŠ¨æ€è°ƒæ•´
            let needsExpansion = false;
            let expansionAttempts = 0;
            const maxExpansionAttempts = 3;
            
            do {
                needsExpansion = false;
                weightPositions = []; // é‡ç½®æƒé‡ä½ç½®è®°å½•
                
                // é¢„è®¡ç®—æ‰€æœ‰æƒé‡ä½ç½®ï¼Œæ£€æµ‹æ˜¯å¦æœ‰æ— æ³•è§£å†³çš„é‡å 
                connections.forEach(conn => {
                    const dx = conn.currentPos.x - conn.prevPos.x;
                    const dy = conn.currentPos.y - conn.prevPos.y;
                    const angle = Math.atan2(dy, dx);
                    
                    const result = findNonOverlappingPosition(
                        conn.prevPos, 
                        conn.currentPos, 
                        conn.tRatio,
                        layoutParams.weightBoxWidth,
                        layoutParams.weightBoxHeight
                    );
                    
                    // è®¡ç®—æ—‹è½¬åçš„æœ‰æ•ˆå°ºå¯¸
                    const cos = Math.abs(Math.cos(angle));
                    const sin = Math.abs(Math.sin(angle));
                    const effectiveWidth = layoutParams.weightBoxWidth * cos + layoutParams.weightBoxHeight * sin;
                    const effectiveHeight = layoutParams.weightBoxWidth * sin + layoutParams.weightBoxHeight * cos;
                    
                    conn.adjustedPos = result;
                    weightPositions.push({
                        x: result.x,
                        y: result.y,
                        width: effectiveWidth,
                        height: effectiveHeight
                    });
                    
                    if (result.needsExpand) {
                        needsExpansion = true;
                    }
                });
                
                if (needsExpansion && expansionAttempts < maxExpansionAttempts) {
                    expansionAttempts++;
                    // å¢åŠ å±‚é—´è·å’Œå‚ç›´é—´è·
                    layoutParams.dynamicLayerWidthMultiplier += 0.25;
                    layoutParams.dynamicVerticalMultiplier += 0.2;
                    
                    // é€’å½’é‡ç»˜
                    console.log(`æƒé‡é‡å æ— æ³•è§£å†³ï¼Œæ‰©å±•å¸ƒå±€å¹¶é‡ç»˜ (å°è¯• ${expansionAttempts})`);
                    return drawNeuralNetwork(true);
                }
            } while (needsExpansion && expansionAttempts < maxExpansionAttempts);

            // 4. ç»˜åˆ¶è¿æ¥çº¿å’Œæƒé‡æ ‡ç­¾
            weightPositions = []; // é‡ç½®ï¼Œè®© createWeightInput é‡æ–°è®¡ç®—
            connections.forEach(conn => {
                // ç»˜åˆ¶è¿æ¥çº¿
                ctx.beginPath();
                ctx.moveTo(conn.prevPos.x, conn.prevPos.y);
                ctx.lineTo(conn.currentPos.x, conn.currentPos.y);
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 1;
                
                // z-aå±‚ä¹‹é—´ï¼ˆåŒä¸€éšè—å±‚ç»„å†…ï¼‰ä½¿ç”¨è™šçº¿
                if (conn.isOneToOne) {
                    ctx.setLineDash([5, 3]); // è™šçº¿æ ·å¼
                } else {
                    ctx.setLineDash([]); // å®çº¿
                }
                ctx.stroke();
                ctx.setLineDash([]); // é‡ç½®ä¸ºå®çº¿
                
                // z-aå±‚ä¹‹é—´ä¸æ˜¾ç¤ºæƒé‡ï¼ˆå®ƒä»¬å±äºåŒä¸€å±‚ï¼‰
                if (!conn.isOneToOne) {
                    // åˆ›å»ºæƒé‡æ ‡ç­¾
                    const inputEl = createWeightInput(
                        conn.layerPairIndex, 
                        conn.fromNode, 
                        conn.toNode, 
                        conn.prevPos, 
                        conn.currentPos, 
                        conn.tRatio,
                        conn.hasIntersection,
                        conn.targetLogicalLayer
                    );
                    if (inputEl) weightInputs.push(inputEl);
                }
            });
            
            // å¦‚æœå¼€å¯äº†æ˜¾ç¤ºæ‰€æœ‰æƒé‡æ¨¡å¼ï¼Œä¿æŒæ˜¾ç¤ºçŠ¶æ€
            if (showAllWeightsMode) {
                const containers = visualizationContainer.querySelectorAll('.weight-container');
                containers.forEach(container => {
                    container.classList.add('visible');
                });
            }
        }
    </script>
</body>
</html>
